{"version":3,"file":"ExtensionFramework.js","sources":["../../../../extensions/src/common/types/enums.ts","../../../../extensions/scripts/node_modules/.pnpm/@rollup+plugin-typescript@11.1.6_rollup@4.18.0_tslib@2.6.3_typescript@5.5.2/node_modules/tslib/tslib.es6.js","../../../../extensions/src/common/utils.ts","../../../../extensions/src/common/globals.ts","../../../../extensions/src/common/ui.ts","../../../../extensions/src/common/IDs.ts","../../../../extensions/src/common/extension/mixins/configurable/customSaveData.ts","../../../../extensions/src/common/cast.ts","../../../../extensions/src/common/extension/mixins/configurable/customArguments/CustomArgumentManager.ts","../../../../extensions/src/common/extension/mixins/configurable/addCostumes/MockBitmapAdapter.ts","../../../../extensions/src/common/extension/mixins/configurable/addCostumes/index.ts","../../../../extensions/src/common/extension/mixins/dependencies.ts","../../../../extensions/src/common/extension/mixins/configurable/customArguments/utils.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/menus.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/util.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/handlers.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/args.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/text.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/index.ts","../../../../extensions/src/common/extension/decorators/blocks.ts","../../../../extensions/src/common/extension/decorators/legacySupport/index.ts","../../../../extensions/src/common/extension/mixins/configurable/legacySupport.ts","../../../../extensions/src/common/extension/mixins/configurable/indicators/svgAlert.ts","../../../../extensions/src/common/extension/mixins/configurable/indicators/index.ts","../../../../extensions/src/common/extension/mixins/configurable/video.ts","../../../../extensions/src/common/extension/mixins/index.ts","../../../../extensions/src/common/extension/mixins/configurable/customArguments/index.ts","../../../../extensions/src/common/extension/mixins/configurable/ui.ts","../../../../extensions/src/common/extension/mixins/configurable/drawable.ts","../../../../extensions/src/common/extension/mixins/configurable/addCostumes/utils.ts","../../../../extensions/src/common/extension/mixins/configurable/blocks/setVideoTransparency.ts","../../../../extensions/src/common/extension/mixins/configurable/blocks/toggleVideoState.ts","../../../../extensions/src/common/extension/mixins/configurable/appInventor/index.ts","../../../../extensions/src/common/extension/ExtensionBase.ts","../../../../extensions/src/common/extension/mixins/base/scratchVersioning/index.ts","../../../../extensions/src/common/extension/mixins/base/supported.ts","../../../../extensions/src/common/extension/index.ts","../../../../extensions/src/common/extension/GenericExtension.ts","../../../../extensions/src/common/extension/decorators/taggedTemplate.ts","../../../../extensions/src/common/extension/decorators/validators.ts"],"sourcesContent":["import { ValueOf } from \"../types\";\n\n/**\n * The different kind of blocks that an extension can define\n */\nexport const BlockType = {\n  /**\n   * Boolean reporter with hexagonal shape\n   */\n  Boolean: 'Boolean',\n\n  /**\n   * A button (not an actual block) for some special action, like making a variable\n   */\n  Button: 'button',\n\n  /**\n   * Command block\n   */\n  Command: 'command',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * The thread continues with the next block whether or not a child branch ran.\n   */\n  Conditional: 'conditional',\n\n  /**\n   * Specialized hat block with no implementation function\n   * This stack only runs if the corresponding event is emitted by other code.\n   */\n  Event: 'event',\n\n  /**\n   * Hat block which conditionally starts a block stack\n   */\n  Hat: 'hat',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * If a child branch runs, the thread evaluates the loop block again.\n   */\n  Loop: 'loop',\n\n  /**\n   * General reporter with numeric or string value\n   */\n  Reporter: 'reporter'\n} as const;\n\nexport const ArgumentType = {\n  /** Numeric value with angle picker. */\n  Angle: \"angle\",\n\n  /** Boolean value with hexagonal placeholder. */\n  Boolean: \"Boolean\",\n\n  /** Numeric value with color picker. */\n  Color: \"color\",\n\n  /** Numeric value with text field. */\n  Number: \"number\",\n\n  /** String value with text field. */\n  String: \"string\",\n\n  /** String value with matrix field. */\n  Matrix: \"matrix\",\n\n  /** MIDI note number with note picker (piano) field. */\n  Note: \"note\",\n\n  /** Inline image on block (as part of the label). */\n  Image: \"image\",\n\n  /** Type added by PRG to support custom arguments */\n  Custom: \"custom\"\n} as const;\n\n/**\n * Default types of Target supported by the VM\n * @enum {string} as const;\n */\nexport const TargetType = {\n  /**\n   * Rendered target which can move, change costumes, etc.\n   */\n  Sprite: 'sprite',\n\n  /**\n   * Rendered target which cannot move but can change backdrops\n   */\n  Stage: 'stage'\n} as const;\n\n/**\n * These constants are copied from scratch-blocks/core/constants.js\n * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?\n * @readonly\n * @enum {int} as const;\n */\nexport const ScratchBlocksConstants = {\n  /**\n   * ENUM for output shape: hexagonal (booleans/predicates).\n   * @const\n   */\n  OutputShapeHexagonal: 1,\n\n  /**\n   * ENUM for output shape: rounded (numbers).\n   * @const\n   */\n  OutputShapeRound: 2,\n\n  /**\n   * ENUM for output shape: squared (any/all values; strings).\n   * @const\n   */\n  OutputShapeSquare: 3\n} as const;\n\nexport const StageLayering = {\n  BackgroundLayer: 'background',\n  VideoLayer: 'video',\n  PenLayer: 'pen',\n  SpriteLayer: 'sprite',\n} as const;\n\nexport const LayerGroups: readonly ValueOf<typeof StageLayering>[] = [\n  StageLayering.VideoLayer,\n  StageLayering.SpriteLayer,\n  StageLayering.BackgroundLayer,\n  StageLayering.PenLayer,\n] as const;\n\nexport const VariableType = {\n  /**\n   * Type representation for scalar variables.\n   * This is currently represented as ''\n   * for compatibility with blockly.\n   */\n  Scalar: '',\n  /**\n   * Type representation for list variables.\n   */\n  List: 'list',\n\n  BrooadcastMessage: 'broadcast_msg'\n} as const;\n\nexport const Branch = {\n  Exit: 0,\n  Enter: 1,\n  First: 1,\n  Second: 2,\n  Third: 3,\n  Fourth: 4,\n  Fifth: 5,\n  Sixth: 6,\n  Seventh: 7\n} as const;\n\nexport const Language = {\n  Аҧсшәа: 'ab',\n  العربية: 'ar',\n  አማርኛ: 'am',\n  Azeri: 'az',\n  Bahasa_Indonesia: 'id',\n  Беларуская: 'be',\n  Български: 'bg',\n  Català: 'ca',\n  Česky: 'cs',\n  Cymraeg: 'cy',\n  Dansk: 'da',\n  Deutsch: 'de',\n  Eesti: 'et',\n  Ελληνικά: 'el',\n  English: 'en',\n  Español: 'es',\n  Español_Latinoamericano: 'es-419',\n  Euskara: 'eu',\n  فارسی: 'fa',\n  Français: 'fr',\n  Gaeilge: 'ga',\n  Gàidhlig: 'gd',\n  Galego: 'gl',\n  한국어: 'ko',\n  עִבְרִית: 'he',\n  Hrvatski: 'hr',\n  isiZulu: 'zu',\n  Íslenska: 'is',\n  Italiano: 'it',\n  ქართული_ენა: 'ka',\n  Kiswahili: 'sw',\n  Kreyòl_ayisyen: 'ht',\n  کوردیی_ناوەندی: 'ckb',\n  Latviešu: 'lv',\n  Lietuvių: 'lt',\n  Magyar: 'hu',\n  Māori: 'mi',\n  Nederlands: 'nl',\n  日本語: 'ja',\n  にほんご: 'ja-Hira',\n  Norsk_Bokmål: 'nb',\n  Norsk_Nynorsk: 'nn',\n  Oʻzbekcha: 'uz',\n  ไทย: 'th',\n  ភាសាខ្មែរ: 'km',\n  Polski: 'pl',\n  Português: 'pt',\n  Português_Brasileiro: 'pt-br',\n  Rapa_Nui: 'rap',\n  Română: 'ro',\n  Русский: 'ru',\n  Српски: 'sr',\n  Slovenčina: 'sk',\n  Slovenščina: 'sl',\n  Suomi: 'fi',\n  Svenska: 'sv',\n  Tiếng_Việt: 'vi',\n  Türkçe: 'tr',\n  Українська: 'uk',\n  简体中文: 'zh-cn',\n  繁體中文: 'zh-tw'\n} as const;\n\nexport const LanguageKeys = Object.keys(Language);\n\nexport const RuntimeEvent = {\n  /**\n   * Event name for glowing a script.\n   */\n  ScriptGlowOn: 'SCRIPT_GLOW_ON',\n  /**\n   * Event name for unglowing a script.\n   */\n  ScriptGlowOff: 'SCRIPT_GLOW_OFF',\n  /**\n   * Event name for glowing a block.\n   */\n  BlockGlowOn: 'BLOCK_GLOW_ON',\n  /**\n   * Event name for unglowing a block.\n   */\n  BlockGlowOff: 'BLOCK_GLOW_OFF',\n  /**\n   * Event name for a cloud data update to this project.\n   */\n  HasCloudDataUpdate: 'HAS_CLOUD_DATA_UPDATE',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  TurboModeOn: 'TURBO_MODE_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  TurboModeOff: 'TURBO_MODE_OFF',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  RecordingOn: 'RECORDING_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  RecordingOff: 'RECORDING_OFF',\n  /**\n   * Event name when the project is started (threads may not necessarily be running).\n   */\n  ProjectStart: 'PROJECT_START',\n  /**\n   * Event name when threads start running.\n   * Used by the UI to indicate running status.\n   */\n  ProjectRunStart: 'PROJECT_RUN_START',\n  /**\n   * Event name when threads stop running\n   * Used by the UI to indicate not-running status.\n   */\n  ProjectRunStop: 'PROJECT_RUN_STOP',\n  /**\n   * Event name for project being stopped or restarted by the user.\n   * Used by blocks that need to reset state.\n   */\n  ProjectStopAll: 'PROJECT_STOP_ALL',\n  /**\n   * Event name for target being stopped by a stop for target call.\n   * Used by blocks that need to stop individual targets.\n   */\n  StopForTarget: 'STOP_FOR_TARGET',\n  /**\n   * Event name for visual value report.\n   */\n  VisualReport: 'VISUAL_REPORT',\n  /**\n   * Event name for project loaded report.\n   */\n  ProjectLoaded: 'PROJECT_LOADED',\n  /**\n   * Event name for report that a change was made that can be saved\n   */\n  ProjectChanged: 'PROJECT_CHANGED',\n  /**\n   * Event name for report that a change was made to an extension in the toolbox.\n   */\n  ToolboxExtensionsNeedUpdate: 'TOOLBOX_EXTENSIONS_NEED_UPDATE',\n  /**\n   * Event name for targets update report.\n   */\n  TargetsUpdate: 'TARGETS_UPDATE',\n  /**\n   * Event name for monitors update.\n   */\n  MonitorsUpdate: 'MONITORS_UPDATE',\n  /**\n   * Event name for block drag update.\n   */\n  BlockDragUpdate: 'BLOCK_DRAG_UPDATE',\n  /**\n   * Event name for block drag end.\n   */\n  BlockDragEnd: 'BLOCK_DRAG_END',\n  /**\n   * Event name for reporting that an extension was added.\n   */\n  ExtensionAdded: 'EXTENSION_ADDED',\n  /**\n   * Event name for reporting that an extension as asked for a custom field to be added\n   */\n  ExtensionFieldAdded: 'EXTENSION_FIELD_ADDED',\n  /**\n   * Event name for updating the available set of peripheral devices.\n   * This causes the peripheral connection modal to update a list of available peripherals.\n   */\n  PeripheralListUpdate: 'PERIPHERAL_LIST_UPDATE',\n  /**\n   * Event name for reporting that a peripheral has connected.\n   * This causes the status button in the blocks menu to indicate 'connected'.\n   */\n  PeripheralConnected: 'PERIPHERAL_CONNECTED',\n  /**\n   * Event name for reporting that a peripheral has been intentionally disconnected.\n   * This causes the status button in the blocks menu to indicate 'disconnected'.\n   */\n  PeripheralDisconnected: 'PERIPHERAL_DISCONNECTED',\n  /**\n   * Event name for reporting that a peripheral has encountered a request error.\n   * This causes the peripheral connection modal to switch to an error state.\n   */\n  PeripheralRequestError: 'PERIPHERAL_REQUEST_ERROR',\n  /**\n   * Event name for reporting that a peripheral connection has been lost.\n   * This causes a 'peripheral connection lost' error alert to display.\n   */\n  PeripheralConnectionLostError: 'PERIPHERAL_CONNECTION_LOST_ERROR',\n  /**\n   * Event name for reporting that a peripheral has not been discovered.\n   * This causes the peripheral connection modal to show a timeout state.\n   */\n  PeripheralScanTimeout: 'PERIPHERAL_SCAN_TIMEOUT',\n  /**\n   * Event name to indicate that the microphone is being used to stream audio.\n   */\n  MicListening: 'MIC_LISTENING',\n  /**\n   * Event name for reporting that blocksInfo was updated.\n   */\n  BlocksInfoUpdate: 'BLOCKSINFO_UPDATE',\n  /**\n   * Event name when the runtime tick loop has been started.\n   */\n  RuntimeStarted: 'RUNTIME_STARTED',\n  /**\n   * Event name when the runtime dispose has been called.\n   */\n  RuntimeDisposed: 'RUNTIME_DISPOSED',\n  /**\n   * Event name for reporting that a block was updated and needs to be rerendered.\n   */\n  BlocksNeedUpdate: 'BLOCKS_NEED_UPDATE',\n  /**\n   * Report that a new target has been created, possibly by cloning an existing target.\n   */\n  TargetWasCreated: 'targetWasCreated',\n  Say: \"SAY\"\n} as const;\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import { MenuItem, Primitive, RGBObject } from \"./types\"\n\ntype FetchParams = {\n  request: Parameters<typeof fetch>[0],\n  options: Parameters<typeof fetch>[1]\n}\n\nexport const getValueFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { value: T }).value : item;\n\nexport const getTextFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { text: string }).text : item;\n\nexport async function fetchWithTimeout(\n  resource: FetchParams[\"request\"],\n  options: FetchParams[\"options\"] & { timeoutMs: number }\n) {\n  const { timeoutMs: timeout } = options;\n\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n\n  const response = await fetch(resource, {\n    ...options,\n    signal: controller.signal\n  });\n\n  clearTimeout(id);\n\n  return response;\n}\n\n/**\n * A utility to wait a certain amount of milliseconds in an async function.\n * @param timeMs \n * @returns \n */\nexport async function untilTimePassed(timeMs: number) {\n  let timeout: NodeJS.Timeout;\n  return await new Promise<void>(\n    (resolve) =>\n      timeout = setTimeout(\n        () => {\n          clearTimeout(timeout);\n          resolve();\n        },\n        timeMs)\n  );\n}\n\nexport async function untilObject<T>(getter: () => T, delay: number = 100): Promise<T> {\n  let timeout: NodeJS.Timeout;\n  let value: T = getter();\n  while (!value) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n    value = getter();\n  }\n  clearTimeout(timeout);\n  return value;\n}\n\nexport async function untilCondition(condition: () => boolean, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!condition()) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport async function untilReady<T extends { ready: boolean }>(obj: T, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!obj.ready) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport const isString = (query: any): query is string => typeof query === 'string' || query instanceof String;\n\nexport const isFunction = (query: any): query is (...args: any[]) => any =>\n  Object.prototype.toString.call(query) === \"[object Function]\"\n  || \"function\" === typeof query\n  || query instanceof Function;\n\nexport const isPrimitive = (query: any): query is Primitive => query !== Object(query);\n\nexport const splitOnCapitals = (query: string) => query.split(/(?=[A-Z])/);\n\n/**\n * A type safe utility function for copy values from one object to another\n * @param param0 object containing the target to copy values to and the source of the values to copy\n */\nexport const copyTo = <TTarget extends object, TSource extends { [k in keyof TTarget]?: TTarget[k] }>({ target, source }: { target: TTarget, source: TSource }) => {\n  for (const key in source) {\n    if (!(key in target)) continue;\n    // @ts-ignore -- the types of the function should ensure this is valid TS\n    target[key] = source[key]\n  }\n}\n\nexport const identity = (x: any) => x;\n\nexport const loadExternalScript = (url: string, onLoad: () => void, onError?: () => void) => {\n  const script = document.createElement('script');\n\n  script.onload = onLoad;\n\n  script.onerror = onError ?? (() => {\n    throw new Error(`Error loading endpoint: ${url}`)\n  });\n\n  script.src = url;\n  script.async = true;\n\n  document.body.appendChild(script);\n}\n\n/**\n * \n * @param url \n * @returns \n */\nexport const untilExternalScriptLoaded = async (url: string): Promise<void> => {\n  const scriptLoaded = new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = url;\n    document.body.appendChild(script);\n  });\n  await scriptLoaded;\n  return;\n}\n\n/**\n * \n * @param url \n * @param globalVariableName \n * @returns \n */\nexport const untilExternalGlobalVariableLoaded = async <T>(url: string, globalVariableName: string): Promise<T> => {\n  if (window[globalVariableName]) return window[globalVariableName];\n  await untilExternalScriptLoaded(url);\n  return window[globalVariableName];\n}\n\n/**\n * Utilize javascript's \"call\" method (on Function.prototype) in a typesafe manner\n * @param fn \n * @param _this \n * @param args \n * @returns \n */\nexport const typesafeCall = <Args extends any[], Return, This, Fn extends (this: This, ...args: Args) => Return>(fn: Fn, _this: This, ...args: Args) => fn.call(_this, ...args) as Return;\n\nexport const set = <T extends object, K extends keyof T>(container: T, key: K, value: T[K]) => {\n  container[key] = value;\n  return container;\n}\n\nexport const assertSameLength = (...collections: any[][]) => {\n  const { size } = collections.reduce((set, { length }) => set.add(length), new Set<number>());\n  if (size !== 1) throw new Error(\"Zip failed because collections weren't equal length\");\n}\n\n/**\n * Convert a Scratch decimal color to a hex string, #RRGGBB.\n * @param {number} decimal RGB color as a decimal.\n * @return {string} RGB color as #RRGGBB hex string.\n */\nconst decimalToHex = (decimal: number) => {\n  if (decimal < 0) {\n    decimal += 0xFFFFFF + 1;\n  }\n  let hex = Number(decimal).toString(16);\n  hex = `#${'000000'.substr(0, 6 - hex.length)}${hex}`;\n  return hex;\n}\n\nexport const decimalToRgb = (decimal: number) => {\n  const a = (decimal >> 24) & 0xFF;\n  const r = (decimal >> 16) & 0xFF;\n  const g = (decimal >> 8) & 0xFF;\n  const b = decimal & 0xFF;\n  return { r: r, g: g, b: b, a: a > 0 ? a : 255 } satisfies RGBObject & { a: number };\n}\n\n/**\n * Convert an RGB color object to a Scratch decimal color.\n * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n * @return {!number} Number representing the color.\n */\nfunction rgbToDecimal(rgb: RGBObject) {\n  return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n}\n\n/**\n * Convert an RGB color object to a hex color.\n * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n * @return {!string} Hex representation of the color.\n */\nexport const rgbToHex = (rgb: RGBObject) => decimalToHex(rgbToDecimal(rgb));\n\nexport const hexToRgb = (hex: string) => {\n  const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null satisfies RGBObject;\n}\n\n/**\n * Keep a number between two limits, wrapping \"extra\" into the range.\n * e.g., wrapClamp(7, 1, 5) == 2\n * wrapClamp(0, 1, 5) == 5\n * wrapClamp(-11, -10, 6) == 6, etc.\n * @param {!number} n Number to wrap.\n * @param {!number} min Minimum limit.\n * @param {!number} max Maximum limit.\n * @return {!number} Value of n wrapped between min and max.\n */\nexport const wrapClamp = (n, min, max) => {\n  const range = (max - min) + 1;\n  return n - (Math.floor((n - min) / range) * range);\n}\n\n/**\n * Create an event (within extension framework code, i.e. `extensions/src`) that can be subscribed to at _bundling time_. \n * \n * As a mental short-hand, you can think of this as a macro-esque mechanism.\n * \n * @see macro-link Macros\n * \n * @description\n * This **_works_** as it tries to create an object in the global scope, which is interacted with both from bundling-related code, \n * as well as the extension framework code \n * (as long as that code is executed at the _top-level_, and the runtime is NodeJS, not the browser). \n * \n * The reason why it's important the framework-based code is _top-level_ is because the framework sourcecode will actually be evaluated at _bundle time_, \n * meaning all _top-level_ expressions will be executed. \n * \n * This allows for the desired event mechanism: \n * > 1. Bundling-related code associates callbacks with a certain event (an entry to an object in global scope), \n * > 2. Framework code tries to fire the callbacks of a given event (when it is executed after step 1)\n * \n * @see top-level Top-level Code\n\n * **NOTE:** This function returns a non-null value only in NodeJS environments.\n * @param identifier \n * @returns \n */\nexport const tryCreateBundleTimeEvent = <Payload>(identifier: string) => {\n  const environment = typeof window === 'undefined' ? \"node\" : \"browser\";\n\n  if (environment !== \"node\") return null;\n\n  const key = `Bundle Time Event: ${identifier}`;\n\n  type Unregister = () => void;\n  type Callback = (details: Payload, removeSelf: Unregister) => void;\n  type Register = (callback: Callback) => Unregister;\n  type Callbacks = Record<symbol, Callback>;\n\n  const get = () => {\n    global[key] ??= {};\n    return global[key] as Callbacks;\n  }\n\n  const registerCallback: Register = (callback) => {\n    const id = Symbol(key);\n    get()[id] = callback;\n    return () => delete get()?.[id];\n  };\n\n  type Fire = (details: Payload) => void;\n\n  const fire: Fire = (details) => {\n    const callbackIDs = Object.getOwnPropertySymbols(get());\n    for (const id of callbackIDs) get()[id]?.(details, () => delete get()?.[id]);\n  };\n\n  return { registerCallback, fire };\n}\n\n/**\n * from: https://www.geeksforgeeks.org/how-to-create-a-guid-uuid-in-javascript/\n * @returns \n */\nexport const uuidv4 = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  .replace(/[xy]/g, function (c) {\n    const r = Math.random() * 16 | 0,\n      v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n","export const openUIEvent = \"OPEN_UI_FROM_EXTENSION\";\nexport const registerButtonCallbackEvent = \"REGISTER_BUTTON_CALLBACK_FROM_EXTENSION\";\nexport const FrameworkID = \"ExtensionFramework\";\nexport const AuxiliaryExtensionInfo = \"AuxiliaryExtensionInfo\";\n\n/**\n * Literal values that control the interaction between the extension framework and the Scratch GUI,\n * specifically how dropdowns (tied to dynamic menus) are co-opted to support custom block arguments.\n */\nexport const guiDropdownInterop = {\n    runtimeKey: \"prgDropdownCustomization\",\n    runtimeProperties: {\n        stateKey: \"state\",\n        entryKey: \"entry\",\n        updateMethodKey: \"update\",\n    },\n    state: {\n        open: \"open\",\n        init: \"init\",\n        update: \"update\",\n        close: \"close\",\n    },\n} as const;\n\nexport const blockIDKey = \"blockID\";","import { Extension as BaseExtension } from \"./extension/GenericExtension\";\nimport { openUIEvent, registerButtonCallbackEvent } from \"./globals\";\nimport { Runtime } from \"./types/scratch/vm\";\n\nexport type ReactivityDependency = any | any[];\n\nexport const activeClass = true;\n\nexport const px = (numberOf: number) => `${numberOf}px`;\n\ntype UniqueKeys<Extension> = Exclude<keyof Extension, keyof BaseExtension<any, any>>;\ntype Methods<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? K : never };\ntype Properties<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? never : K };\ntype MethodParams<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? Parameters<Extension[Key]> : never };\ntype MethodReturns<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? ReturnType<Extension[Key]> : never };\n\nexport type ReactiveInvoke<Extension> = <T extends keyof Methods<Extension>>(funcName: Methods<Extension>[T] extends never ? never : T, ...args: MethodParams<Extension>[T]) => MethodReturns<Extension>[T];\nexport type ReactiveSet<Extension> = <T extends keyof Properties<Extension>>(propertyName: Properties<Extension>[T] extends never ? never : T, value: Extension[T]) => void;\n\nexport type ReactiveMethods<Extension> = {\n  invoke: ReactiveInvoke<Extension>;\n  set: ReactiveSet<Extension>;\n}\n\nexport const reactiveInvoke = <Extension, T extends keyof Methods<Extension>>(extensionAssignment: Extension, funcName: T, args: MethodParams<Extension>[T]): MethodReturns<Extension>[T] => {\n  return (extensionAssignment[funcName] as Function)(...args);\n}\n\nexport const reactiveSet = <Extension, T extends keyof Properties<Extension>>(extensionAssignment: Extension, propertyName: T, value: Extension[T]): void => {\n  extensionAssignment[propertyName] = value;\n}\n\nexport const openUI = (runtime: Runtime, details: { id: string, name: string, component: string, label?: string }) => runtime.emit(openUIEvent, details);\n\nexport const registerButtonCallback = (runtime: Runtime, buttonID: string, callback: (...args: any[]) => void) => {\n  runtime.emit(registerButtonCallbackEvent, buttonID);\n  runtime.on(buttonID, callback);\n}\n\nconst enum Color {\n  ui = \"ui\",\n  text = \"text\",\n  motion = \"motion\",\n  red = \"red\",\n  sound = \"sound\",\n  control = \"control\",\n  data = \"data\",\n  pen = \"pen\",\n  error = \"error\",\n  extensions = \"extensions\",\n  drop = \"drop\"\n}\n\n/**\n * Makes it easier to reference the css color variables defined in prg-extension-boilerplate/scratch-packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nclass CssVar {\n  root: Color;\n\n  constructor(root: Color) { this.root = root }\n\n  get(...parts: string[]) { return `var(--${this.root}-${parts.join(\"-\")})` }\n  primary(...parts: string[]) { return this.get(\"primary\", ...parts) }\n  secondary(...parts: string[]) { return this.get(\"secondary\", ...parts) }\n  tertiary(...parts: string[]) { return this.get(\"tertiary\", ...parts) }\n  transparent(...parts: string[]) { return this.get(\"transparent\", ...parts) }\n  light(...parts: string[]) { return this.get(\"light\", ...parts) }\n}\n\nconst ui = new CssVar(Color.ui);\nconst text = new CssVar(Color.text);\nconst motion = new CssVar(Color.motion);\nconst red = new CssVar(Color.red);\nconst sound = new CssVar(Color.sound);\nconst control = new CssVar(Color.control);\nconst data = new CssVar(Color.data);\nconst pen = new CssVar(Color.pen);\nconst error = new CssVar(Color.error);\nconst extensions = new CssVar(Color.extensions);\nconst drop = new CssVar(Color.extensions);\n\n/**\n * Color variable references corresponding to the css variables defined in prg-extension-boilerplate/scratch-packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nexport const color = {\n  \"ui\": {\n    primary: ui.primary(),\n    secondary: ui.secondary(),\n    tertiary: ui.tertiary(),\n    modalOverlay: ui.get(\"modal\", \"overlay\"),\n    white: ui.get(\"white\"),\n    whiteDim: ui.get(\"white\", \"dim\"),\n    whiteTransparent: ui.get(\"white\", \"transparent\"),\n    transparent: ui.transparent(),\n    blackTransparent: ui.get(\"black\", \"transparent\"),\n  },\n  \"text\": {\n    primary: text.primary(),\n    primaryTransparent: text.transparent(),\n  },\n  \"motion\": {\n    primary: motion.primary(),\n    tertiary: motion.tertiary(),\n    transparent: motion.get(\"transparent\"),\n    lightTansparent: motion.light(\"transparent\"),\n  },\n  \"red\": {\n    primary: red.primary(),\n    tertiary: red.tertiary(),\n  },\n  \"sound\": {\n    primary: sound.primary(),\n    tertiary: sound.tertiary(),\n  },\n  \"control\": {\n    primary: control.primary(),\n  },\n  \"data\": {\n    primary: data.primary(),\n  },\n  \"pen\": {\n    primary: pen.primary(),\n    transparent: pen.transparent(),\n  },\n  \"error\": {\n    primary: error.primary(),\n    light: error.light(),\n    transparent: error.transparent(),\n  },\n  \"extensions\": {\n    primary: extensions.primary(),\n    tertiary: extensions.tertiary(),\n    light: extensions.light(),\n    transparent: extensions.transparent(),\n  },\n  \"drop\": {\n    highlight: drop.get(\"highlight\")\n  }\n}","const validRegEx = new RegExp('^[a-z0-9]+$', 'i');\nconst invalidRegEx = new RegExp('[^a-z0-9]+', 'gi');\n\nexport const isValidID = (id) => validRegEx.test(id);\n\nconst guard = 'prg';\nconst guards = [guard, guard.split(\"\").reverse().join(\"\")];\n\nconst guardsRegEx = new RegExp(`${guards[0]}([0-9]+)${guards[1]}`, 'g');\n\nconst wrap = (str) => `${guards[0]}${str}${guards[1]}`;\n\nconst replaceAll = (query, current, desired) => query.replaceAll(current, desired);\n\nexport const encode = (query: string): string => {\n  const matches = [...query.matchAll(invalidRegEx)];\n  const invalidCharacters = matches.reduce((set, current) => {\n    current[0].split(\"\").forEach(char => set.add(char));\n    return set;\n  }, new Set<string>());\n  const replacements = [...invalidCharacters].map(char => ({ char, code: char.charCodeAt(0) }));\n  return replacements.reduce((modified, { char, code }) => replaceAll(modified, char, wrap(code)), `${query}`);\n}\n\nexport const decode = (query: string): string => {\n  const matches = [...query.matchAll(guardsRegEx)];\n  const replacements = matches.reduce((replacements, match) => {\n    const [key, code] = match;\n    return replacements.set(key, String.fromCharCode(code as any as number));\n  }, new Map());\n  return [...replacements].reduce((modified, [current, desired]) => replaceAll(modified, current, desired), `${query}`);\n}","import { BaseGenericExtension, NonAbstractConstructor } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../base\";\nimport { ExtensionInstanceWithFunctionality } from \"..\";\n\n/**\n * WARNING! If you change this key, it will affect already saved projects.\n * Do not rename this without first developing a mechanism for searching for previously used keys.\n */\nexport const saveDataKey = \"customSaveDataPerExtension\" as const;\n\n/**\n * @summary Utility class to assist in creating a (typesafe) object that, for a given Extension type, handles both:\n * - writing out data on save\n * - doing something with save data on load\n * \n * @description This class's constructor takes an object with both an `onSave` and an `onLoad` method\n * (and the `onSave`'s return type must match `onLoad`'s argument type)\n * @example\n * new SaveDataHandler({\n *    Extension: MyExtension,\n *    onSave: () => ({x: 0, y: 3}),\n *    onLoad: (data) => {\n *       const sum = data.x + data.y; // do something with saved data\n *    }\n * })\n * @todo Remove the `BaseGenericExtension` Generic Type restraint once Generic Extensions are no longer supported\n */\nexport class SaveDataHandler<T extends BaseGenericExtension | ExtensionInstanceWithFunctionality<[\"customSaveData\"]>, TData> {\n  constructor(public hooks: {\n    // @ts-ignore\n    Extension: NonAbstractConstructor<T>,\n    onSave: (self: T) => TData,\n    onLoad: (self: T, data: TData) => void,\n  }) { }\n}\n\n/**\n * Mixin the ability for extensions to save and reload custom data (including any data related to custom arguments)\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function mixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomSaveDataSupport extends Ctor {\n    /**\n     * Optional field that can be defined if you need to save custom data for an extension \n     * (like some extension specific variable, or an API endpoint).\n     * @example\n     * class Example extends Extension<..., ...> {\n     *    someValue = 5;\n     *    ...\n     *    saveDataHandler = new SaveDataHandler({\n     *      Extension: Example,\n     *      // NOTE: The type info for 'instance' could be left off in the line below\n     *      onSave: (instance: Example) => ({ valueToSave: instance.someValue }),\n     *      onLoad: (instance, data) => instance.someValue = data.valueToSave\n     *    })\n     * }\n     * @see Extension.MakeSaveDataHandler\n     */\n    protected saveDataHandler: SaveDataHandler<ExtensionWithCustomSaveDataSupport, any> = undefined;\n\n    /**\n     * Save function called 'internally' by the VM when serializing a project.\n     * @param toSave \n     * @param extensionIDs \n     * @returns \n     */\n    private save(toSave: { [saveDataKey]: Record<string, any> }, extensionIDs: Set<string>) {\n      const { saveDataHandler, id } = this;\n      const argumentManager = this.supports(\"customArguments\") ? this.customArgumentManager : null;\n      const saveData = saveDataHandler?.hooks.onSave(this) ?? {};\n      argumentManager?.saveTo(saveData);\n      if (Object.keys(saveData).length === 0) return;\n      const container = toSave[saveDataKey];\n      container ? (container[id] = saveData) : (toSave[saveDataKey] = { [id]: saveData });\n      extensionIDs.add(id);\n    }\n\n    /**\n     * Load function called 'internally' by the VM when loading a project.\n     * Will be invoked on an extension immediately after it is constructed.\n     * @param saved \n     * @returns \n     */\n    private load(saved: { [saveDataKey]: Record<string, any> }) {\n      if (!saved) return;\n      const { saveDataHandler, id } = this;\n      const saveData = saveDataKey in saved ? saved[saveDataKey][id] : null;\n      if (!saveData) return;\n      saveDataHandler?.hooks.onLoad(this, saveData);\n\n      if (this.supports(\"customArguments\")) this.customArgumentManager.loadFrom(saveData);\n    }\n  }\n  return ExtensionWithCustomSaveDataSupport;\n}","import { ArgumentType } from \"./types/enums\";\nimport { TypeByArgumentType, ValueOf } from \"./types\";\nimport { decimalToRgb, hexToRgb } from \"./utils\";\n\nexport const castToType = (argumentType: ValueOf<typeof ArgumentType>, value: any) => {\n  switch (argumentType) {\n    case ArgumentType.String:\n      return `${value}`;\n    case ArgumentType.Number:\n      return parseFloat(value);\n    case ArgumentType.Boolean:\n      return JSON.parse(value ?? false);\n    case ArgumentType.Note:\n      return parseInt(value);\n    case ArgumentType.Angle:\n      return parseInt(value);\n    case ArgumentType.Matrix:\n      return toMatrix(value);\n    case ArgumentType.Color:\n      return typeof value === 'string' && value.substring(0, 1) === '#'\n        ? hexToRgb(value) ?? { r: 0, g: 0, b: 0, a: 255 }\n        : decimalToRgb(castToType(\"number\", value));\n    default:\n      throw new Error(`Method not implemented for value of ${value} and type ${argumentType}`);\n  }\n}\n\nexport const tryCastToArgumentType = <T extends ValueOf<typeof ArgumentType>>(\n  argumentType: T,\n  value: any,\n  onFailure: (value: any) => TypeByArgumentType<T>\n): TypeByArgumentType<T> => {\n  try {\n    const casted = castToType(argumentType, value);\n    return casted as TypeByArgumentType<T>;\n  }\n  catch {\n    return onFailure(value);\n  }\n}\n\nconst toFlag = (value: string): boolean => parseInt(value) === 1;\n\nconst toMatrix = (matrixString: string): boolean[][] => {\n  if (matrixString.length !== 25) return new Array(5).fill(new Array(5).fill(false));\n\n  const entries = matrixString.split('');\n  const matrix = entries.map(toFlag).reduce((matrix, flag, index) => {\n    const row = Math.floor(index / 5);\n    const column = index % 5;\n    (column === 0) ? matrix[row] = [flag] : matrix[row].push(flag);\n    return matrix;\n  }, new Array<boolean[]>(5));\n\n  return matrix;\n}","import { uuidv4 } from \"$common/utils\";\nimport { ArgumentEntry, ArgumentEntrySetter, ArgumentID } from \"./utils\";\n\nconst entries: ArgumentEntry<any>[] = [];\n\nconst serialize = <T>(entry: ArgumentEntry<T>) => JSON.stringify(entry);\n\ntype ArgumentEntryWithID<T = any> = { entry: ArgumentEntry<T>, id: string };\ntype SaveObject = { [k in typeof CustomArgumentManager[\"SaveKey\"]]: ArgumentEntryWithID[] }\n\nexport default class CustomArgumentManager {\n  private valueLookup: Map<string, ArgumentEntry<any>> = new Map();\n  private idLookup: Map<string, string> = new Map();\n  private current: ArgumentID = null;\n\n  private setCurrent(id: ArgumentID) { return (this.current = id) }\n\n  private setEntry<T>(entry: ArgumentEntry<T>) { return this.idLookup.get(serialize(entry)) ?? this.add(entry); }\n\n  private insert<T>({ id, entry }: ArgumentEntryWithID<T>, serializedEntry?: string) {\n    this.valueLookup.set(id, entry);\n    this.idLookup.set(serializedEntry ?? serialize(entry), id);\n    entries.push({ text: entry.text, value: id });\n  }\n\n  get entries() { return entries }\n\n  add<T>(entry: ArgumentEntry<T>): string {\n    const serialized = serialize(entry);\n    const cached = this.idLookup.get(serialized);\n    if (cached) return cached;\n    const id = CustomArgumentManager.GetIdentifier();\n    this.insert({ id, entry }, serialized);\n    return id;\n  }\n\n  request<T>(id: ArgumentID, update: (id: ArgumentID) => void): ArgumentEntrySetter<T> {\n    this.setCurrent(id);\n    return (entry) => update(this.setCurrent(this.setEntry(entry)));\n  }\n\n  getCurrent() { return { text: this.getEntry(this.current).text, value: this.current }; }\n\n  getEntry(id: string) { return this.valueLookup.get(id) }\n\n  requiresSave() { this.valueLookup.size > 0 }\n\n  saveTo(obj: SaveObject) {\n    const entries = Array.from(this.valueLookup.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, entry]) => ({ id, entry }));\n    if (entries.length === 0) return;\n    obj[CustomArgumentManager.SaveKey] = entries;\n  }\n\n  loadFrom(obj: SaveObject) {\n    obj[CustomArgumentManager.SaveKey]?.forEach(saved => this.insert(saved));\n  }\n\n  /**\n   * @todo Implement this if it becomes necessary (i.e the every growing size of the internal maps become an issue)\n   */\n  private purgeStaleIDs() {\n    // Somehow, tap into blockly to loop through all current blocks & their field dropdowns.\n    // Collect all field dropdowns values. \n    // Then, loop over entries in this.map -- if the values don't appear in the collected in-use values, drop those items.\n    // NOTE: The blocks in the 'pallette' do not show up in a target's \"blocks\" object, which makes this trickier.\n  }\n\n  static IsIdentifier = (query: string) => query.startsWith(CustomArgumentManager.IdentifierPrefix);\n  static SaveKey = \"internal_customArgumentsSaveData\" as const;\n  private static GetIdentifier = () => CustomArgumentManager.IdentifierPrefix + uuidv4();\n  private static IdentifierPrefix = \"__customArg__\";\n}","/**\n * Class adapted from: https://github.com/LLK/scratch-svg-renderer/blob/develop/src/bitmap-adapter.js\n */\nexport default class {\n  private makeImage() { return new Image() }\n  private makeCanvas() { return document.createElement('canvas') }\n\n  /**\n   * Return a canvas with the resized version of the given image, done using nearest-neighbor interpolation\n   * @param {CanvasImageSource} image The image to resize\n   * @param {int} newWidth The desired post-resize width of the image\n   * @param {int} newHeight The desired post-resize height of the image\n   * @returns {HTMLCanvasElement} A canvas with the resized image drawn on it.\n   */\n  resize(image, newWidth, newHeight) {\n    // We want to always resize using nearest-neighbor interpolation. However, canvas implementations are free to\n    // use linear interpolation (or other \"smooth\" interpolation methods) when downscaling:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1360415\n    // It seems we can get around this by resizing in two steps: first width, then height. This will always result\n    // in nearest-neighbor interpolation, even when downscaling.\n    const stretchWidthCanvas = this.makeCanvas();\n    stretchWidthCanvas.width = newWidth;\n    stretchWidthCanvas.height = image.height;\n    let context = stretchWidthCanvas.getContext('2d');\n    context.imageSmoothingEnabled = false;\n    context.drawImage(image, 0, 0, stretchWidthCanvas.width, stretchWidthCanvas.height);\n    const stretchHeightCanvas = this.makeCanvas();\n    stretchHeightCanvas.width = newWidth;\n    stretchHeightCanvas.height = newHeight;\n    context = stretchHeightCanvas.getContext('2d');\n    context.imageSmoothingEnabled = false;\n    context.drawImage(stretchWidthCanvas, 0, 0, stretchHeightCanvas.width, stretchHeightCanvas.height);\n    return stretchHeightCanvas;\n  }\n\n  /**\n   * Scratch 2.0 had resolution 1 and 2 bitmaps. All bitmaps in Scratch 3.0 are equivalent\n   * to resolution 2 bitmaps. Therefore, converting a resolution 1 bitmap means doubling\n   * it in width and height.\n   * @param {!string} dataURI Base 64 encoded image data of the bitmap\n   * @param {!function} callback Node-style callback that returns updated dataURI if conversion succeeded\n   */\n  convertResolution1Bitmap(dataURI, callback) {\n    const image = new Image();\n    image.src = dataURI;\n    image.onload = () => {\n      callback(null, this.resize(image, image.width * 2, image.height * 2).toDataURL());\n    };\n    image.onerror = () => {\n      callback('Image load failed');\n    };\n  }\n\n  /**\n   * Given width/height of an uploaded item, return width/height the image will be resized\n   * to in Scratch 3.0\n   * @param {!number} oldWidth original width\n   * @param {!number} oldHeight original height\n   * @return {object} Array of new width, new height\n   */\n  getResizedWidthHeight(oldWidth, oldHeight) {\n    const STAGE_WIDTH = 480;\n    const STAGE_HEIGHT = 360;\n    const STAGE_RATIO = STAGE_WIDTH / STAGE_HEIGHT;\n\n    // If both dimensions are smaller than or equal to corresponding stage dimension,\n    // double both dimensions\n    if ((oldWidth <= STAGE_WIDTH) && (oldHeight <= STAGE_HEIGHT)) {\n      return { width: oldWidth * 2, height: oldHeight * 2 };\n    }\n\n    // If neither dimension is larger than 2x corresponding stage dimension,\n    // this is an in-between image, return it as is\n    if ((oldWidth <= STAGE_WIDTH * 2) && (oldHeight <= STAGE_HEIGHT * 2)) {\n      return { width: oldWidth, height: oldHeight };\n    }\n\n    const imageRatio = oldWidth / oldHeight;\n    // Otherwise, figure out how to resize\n    if (imageRatio >= STAGE_RATIO) {\n      // Wide Image\n      return { width: STAGE_WIDTH * 2, height: STAGE_WIDTH * 2 / imageRatio };\n    }\n    // In this case we have either:\n    // - A wide image, but not with as big a ratio between width and height,\n    // making it so that fitting the width to double stage size would leave\n    // the height too big to fit in double the stage height\n    // - A square image that's still larger than the double at least\n    // one of the stage dimensions, so pick the smaller of the two dimensions (to fit)\n    // - A tall image\n    // In any of these cases, resize the image to fit the height to double the stage height\n    return { width: STAGE_HEIGHT * 2 * imageRatio, height: STAGE_HEIGHT * 2 };\n  }\n\n  /**\n   * Given bitmap data, resize as necessary.\n   * @param {string} fileData Base 64 encoded image data of the bitmap\n   * @param {string} fileType The MIME type of this file\n   * @returns {Promise} Resolves to resized image data Uint8Array\n   */\n  importBitmap(dataURI: string): Promise<Uint8Array> {\n    return new Promise((resolve, reject) => {\n      const image = this.makeImage();\n      image.src = dataURI;\n      image.onload = () => {\n        const newSize = this.getResizedWidthHeight(image.width, image.height);\n        if (newSize.width === image.width && newSize.height === image.height) {\n          // No change\n          resolve(this.convertDataURIToBinary(dataURI));\n        } else {\n          const resizedDataURI = this.resize(image, newSize.width, newSize.height).toDataURL();\n          resolve(this.convertDataURIToBinary(resizedDataURI));\n        }\n      };\n      image.onerror = () => {\n        reject('Image load failed');\n      };\n    });\n  }\n\n  // TODO consolidate with scratch-vm/src/util/base64-util.js\n  // From https://gist.github.com/borismus/1032746\n  convertDataURIToBinary(dataURI) {\n    const BASE64_MARKER = ';base64,';\n    const base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;\n    const base64 = dataURI.substring(base64Index);\n    const raw = window.atob(base64);\n    const rawLength = raw.length;\n    const array = new Uint8Array(new ArrayBuffer(rawLength));\n\n    for (let i = 0; i < rawLength; i++) {\n      array[i] = raw.charCodeAt(i);\n    }\n    return array;\n  }\n}","import type RenderedTarget from \"$scratch-vm/sprites/rendered-target\";\nimport Target from \"$scratch-vm/engine/target\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport MockBitmapAdapter from \"./MockBitmapAdapter\";\nimport { getUrlHelper } from \"./utils\";\n\nlet bitmapAdapter: MockBitmapAdapter;\nlet urlHelper: ReturnType<typeof getUrlHelper>;\n\nconst rendererKey: keyof RenderedTarget = \"renderer\";\nconst isRenderedTarget = (target: Target | RenderedTarget): target is RenderedTarget => rendererKey in target;\nconst notRenderedTargetError = \"Costume could not be added as the supplied target wasn't a rendered target\";\n\n/**\n * Mixin the ability for extensions to add costumes to sprites\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomSupport extends Ctor {\n\n    /**\n     * Add a costume to the current sprite based on same image data\n     * @param {RenderedTarget} target (e.g. `util.target`)\n     * @param {ImageData} image What image to use to create the costume\n     * @param {\"add only\" | \"add and set\"} action What action should be applied\n     * - **_add only_**: generates the costume and append it it to the sprite's costume library\n     * - **_add and set_**: Both generate the costume (adding it to the sprite's costume library) and set it as the sprite's current costume\n     * @param {string?} name optional name to attach to the costume\n     */\n    async addCostume(target: Target, image: ImageData, action: \"add only\" | \"add and set\", name?: string) {\n      urlHelper ??= getUrlHelper(image);\n      await this.addCostumeBitmap(target, urlHelper.getDataURL(image), action, name);\n    }\n\n    /**\n     * Add a costume to the current sprite based on a bitmpa input\n     * @param {Target} target (e.g. `util.target`)\n     * @param {string} bitmapImage What image to use to create the costume\n     * @param {\"add only\" | \"add and set\"} action What action should be applied\n     * - **_add only_**: generates the costume and append it it to the sprite's costume library\n     * - **_add and set_**: Both generate the costume (adding it to the sprite's costume library) and set it as the sprite's current costume\n     * @param {string?} name optional name to attach to the costume\n     */\n    async addCostumeBitmap(target: Target, bitmapImage: string, action: \"add only\" | \"add and set\", name?: string) {\n      if (!isRenderedTarget(target)) return console.error(notRenderedTargetError);\n\n      name ??= `${this.id}_generated_${Date.now()}`;\n      bitmapAdapter ??= new MockBitmapAdapter();\n\n      // storage is of type: https://github.com/LLK/scratch-storage/blob/develop/src/ScratchStorage.js\n      const { storage } = this.runtime;\n      const dataFormat = storage.DataFormat.PNG;\n      const assetType = storage.AssetType.ImageBitmap;\n      const dataBuffer = await bitmapAdapter.importBitmap(bitmapImage);\n\n      const asset = storage.createAsset(assetType, dataFormat, dataBuffer, null, true);\n      const { assetId } = asset;\n      const costume = { name, dataFormat, asset, md5: `${assetId}.${dataFormat}`, assetId };\n\n      await this.runtime.addCostume(costume);\n\n      const { length } = target.getCostumes();\n\n      target.addCostume(costume, length);\n      if (action === \"add and set\") target.setCostume(length);\n    }\n\n    /**\n     * Add a costume to the current sprite based on same image data\n     * @param {Target} target (e.g. `util.target`)\n     * @param {string?} name costume name to look for\n     */\n    setCostumeByName(target: Target, name: string): boolean {\n      if (!isRenderedTarget(target)) {\n        console.error(notRenderedTargetError);\n        return false;\n      }\n\n      let costumeIndex = target.getCostumeIndexByName(name);\n      if (costumeIndex < 0) return false;\n\n      target.setCostume(costumeIndex);\n      return true;\n    }\n\n  }\n\n  return ExtensionWithCustomSupport;\n}\n","import { ValueOf } from \"$common/types\";\nimport { Mixin, MixinName, optionalMixins } from \"./index\";\nimport { MinimalExtensionConstructor } from \"./base\";\n\ntype DependentFunctionality<TBase, TMixinDependencies extends Mixin<unknown>[]> =\n  TMixinDependencies extends [infer Head extends Mixin<unknown>, ...infer Tail extends Mixin<unknown>[]]\n  ? DependentFunctionality<ReturnType<Head> & TBase, Tail>\n  : TBase;\n\nconst dependencyListeners: ((mixins: Mixin<any>[]) => void)[] = []\n\nexport const withDependencies = <\n  Base extends MinimalExtensionConstructor,\n  TMixinDependencies extends Mixin<T>[],\n  T\n>(Ctor: Base, ...dependencies: TMixinDependencies) => {\n  dependencyListeners.pop()?.(dependencies);\n  return Ctor as Base & DependentFunctionality<Base, TMixinDependencies>;\n}\n\nlet mixinsMap: Map<ValueOf<typeof optionalMixins>, keyof typeof optionalMixins>;\n\nexport const tryCaptureDependencies = <TReturn>(createMixin: () => TReturn): { MixedIn: TReturn, dependencies: MixinName[] | null } => {\n\n  mixinsMap ??= Object.entries(optionalMixins).reduce((map, [name, mixin]) => {\n    return map.set(mixin, name as MixinName);\n  }, new Map());\n\n  let dependencies: MixinName[];\n\n  dependencyListeners.push((mixins) => {\n    mixins\n      .map(dependency => dependency as ValueOf<typeof optionalMixins>)\n      .forEach(dependency => {\n        if (!mixinsMap.has(dependency)) throw new Error(\"Unkown mixin dependency! \" + dependency);\n        dependencies ??= [];\n        dependencies.push(mixinsMap.get(dependency));\n      })\n  });\n\n  const MixedIn = createMixin();\n\n  return { dependencies, MixedIn };\n}","import { ExtensionBase } from \"$common/extension/ExtensionBase\";\nimport { guiDropdownInterop, } from \"$common/globals\";\nimport { Environment, ExpandRecursively, SvelteComponentConstructor, ValueOf } from \"$common/types\";\nimport { untilObject } from \"$common/utils\";\n\nexport type ArgumentEntry<T> = { text: string, value: T };\nexport type ArgumentEntrySetter<T, TReturn = void> = (entry: ArgumentEntry<T>) => TReturn;\nexport type ArgumentID = string;\n\nexport type ComponentProps<T, TExtension extends ExtensionBase> = {\n    extension: TExtension,\n    setter: ArgumentEntrySetter<T>,\n    current: ArgumentEntry<T>\n}\n\nexport type NonspecificComponentProps = ComponentProps<any, ExtensionBase>;\n\nexport type CustomArgumentComponent = SvelteComponentConstructor<NonspecificComponentProps>;\n\nexport type CustomArgumentRecipe<T, TExtension extends ExtensionBase> = {\n    /**\n     * The svelte component to render the custom argument UI\n     */\n    component: SvelteComponentConstructor<ComponentProps<T, TExtension>>,\n    /**\n     * The starting value of the the custom argument (including both its value and text representation)\n     */\n    initial: ArgumentEntry<T>,\n    /**\n     * A function that must be defined if you'd like for your custom argument to accept reporters\n     * @param x \n     * @returns \n     */\n    acceptReportersHandler?: (x: any) => ArgumentEntry<T>\n};\n\ntype DropdownEntry = { [k in typeof guiDropdownInterop.runtimeProperties.entryKey]: ArgumentEntry<string> };\ntype DropdownState = { [k in typeof guiDropdownInterop.runtimeProperties.stateKey]: ValueOf<typeof guiDropdownInterop.state> };\ntype DropdownUpdateMethod = { [k in typeof guiDropdownInterop.runtimeProperties.updateMethodKey]: (id: string) => void };\n\nexport type RuntimeWithCustomArgumentSupport = Environment[\"runtime\"] & {\n    [k in typeof guiDropdownInterop.runtimeKey]: ExpandRecursively<DropdownEntry & DropdownState & DropdownUpdateMethod>\n}\n\nconst findUniqueElementByClass = <T extends Element = Element>(container: Document | Element, className: string) => {\n    const elements = container.getElementsByClassName(className);\n    if (elements.length !== 1) throw new Error(`Uh oh! Expected 1 element with class '${className}', but found ${elements.length}`);\n    return elements[0] as T;\n}\n\nconst hideText = (element: Element) => (element as HTMLElement).style.display = \"none\";\n\nexport const renderToDropdown = async <TProps extends NonspecificComponentProps>(Compononent: SvelteComponentConstructor<TProps>, props: TProps) => {\n    const dropdownContainerClass = \"blocklyDropDownContent\";\n    const target = findUniqueElementByClass(document, dropdownContainerClass);\n    const anchor = await untilObject(() => target.children[0]);\n    const component = new Compononent({ target, anchor, props });\n    hideText(anchor);\n}","import { MenuThatAcceptsReporters, DynamicMenuThatAcceptsReporters, Menu, MenuItem, DynamicMenu, ExtensionMenuMetadata, ExtensionArgumentMetadata } from \"$common/types\";\nimport { isFunction, isPrimitive } from \"$common/utils\";\n\nconst reporterItemsKey: keyof MenuThatAcceptsReporters<any> = \"items\";\nconst reporterItemsGetterKey: keyof DynamicMenuThatAcceptsReporters<any> = \"getItems\";\n\nexport const menuProbe = {\n  isSimpleStatic: (menu: Menu<any>): menu is any[] | MenuItem<any>[] => Array.isArray(menu),\n  isSimpleDynamic: (menu: Menu<any>): menu is DynamicMenu<any> => isFunction(menu),\n  isStaticWithReporters: (menu: Menu<any>): menu is MenuThatAcceptsReporters<any> => reporterItemsKey in menu,\n  isDynamicWithReporters: (menu: Menu<any>): menu is DynamicMenuThatAcceptsReporters<any> => reporterItemsGetterKey in menu,\n}\n\nexport const getMenuName = (index: number) => `${index}`;\n\nexport const convertMenuItemsToString = (item: any | MenuItem<any>) =>\n  isPrimitive(item) ? `${item}` : { ...item, value: `${item.value}` };\n\nexport const asStaticMenu = (items: MenuItem<any>[], acceptReporters: boolean) => ({\n  acceptReporters,\n  items: items\n    .map(item => item /**TODO figure out how to format */)\n    .map(convertMenuItemsToString)\n} satisfies ExtensionMenuMetadata);\n\nexport const addOptionsAndGetMenuName = (options: Menu<any>, menus: Menu<any>[],) => {\n  const alreadyAddedIndex = menus.indexOf(options);\n  const menuIndex = alreadyAddedIndex >= 0 ? alreadyAddedIndex : menus.push(options) - 1;\n  return `${getMenuName(menuIndex)}`;\n}\n\nexport const setMenu = (entry: ExtensionArgumentMetadata, options: Menu<any>, menus: Menu<any>[]) =>\n  options ? entry.menu = addOptionsAndGetMenuName(options, menus) : null;","import { BlockMetadata, BlockOperation } from \"$common/types\";\nimport { isFunction } from \"$common/utils\";\n\nexport const format = (text: string, identifier: string, description: string): string => {\n  return text; // make use of formatMessage in the future\n}\n\nexport type BlockGetter<This, Fn extends BlockOperation> = (this: This, self: This) => BlockMetadata<Fn>;\nexport type BlockDefinition<T, Fn extends BlockOperation> = BlockMetadata<Fn> | BlockGetter<T, Fn>;\n\nexport const isBlockGetter = <T, Fn extends BlockOperation>(details: BlockDefinition<any, Fn>): details is BlockGetter<T, Fn> => isFunction(details);\n\nexport const getButtonID = (id: string, opcode: string) => `${id}_${opcode}`;\n\nexport const extractArgNamesFromText = (text: string): string[] => {\n  const textAndNumbersInBrackets = /\\[([A-Za-z0-9]+)\\]/gm;\n  const argNames: string[] = [];\n  for (const [_, result] of text.matchAll(textAndNumbersInBrackets)) {\n    argNames.push(result);\n  }\n  return argNames;\n}","import { Argument, ArgumentType, DynamicMenuThatAcceptsReporters, Menu, MenuThatAcceptsReporters, VerboseArgument } from \"$common/types\";\nimport { isPrimitive, identity } from \"$common/utils\";\n\nexport type Handler = (MenuThatAcceptsReporters<any>['handler']);\nconst isVerbose = (arg: Argument<any>): arg is VerboseArgument<any> => !isPrimitive(arg);\nconst handlerKey: keyof MenuThatAcceptsReporters<any> = 'handler';\nconst hasHandler = (options: Menu<any>): options is MenuThatAcceptsReporters<any> | DynamicMenuThatAcceptsReporters<any> => options && handlerKey in options;\n\nexport const extractHandlers = (args: readonly Argument<any>[]): Handler[] => args.map(element => {\n  if (!isVerbose(element)) return identity;\n  if (element.type === ArgumentType.Image) return identity;\n  const { options } = element;\n  if (!hasHandler(options)) return identity;\n  return options.handler;\n});","import { Argument, ArgumentType, BlockMetadata, BlockOperation, ExtensionArgumentMetadata, InlineImage, Menu, MultipleArgsBlock, OneArgBlock, ValidKey, ValueOf, VerboseArgument } from \"$common/types\";\nimport { assertSameLength, isPrimitive, isString } from \"$common/utils\";\nimport { extractHandlers } from \"./handlers\";\nimport { setMenu } from \"./menus\";\nimport { format } from \"./util\";\n\nexport const getArgName = (index: number) => `${index}`;\n\nconst getArgumentType = <T>(arg: Argument<T>): ValueOf<typeof ArgumentType> =>\n  isPrimitive(arg) ? arg as ValueOf<typeof ArgumentType> : (arg as VerboseArgument<T>).type;\n\n/**\n * Extract an array of args tied to a block \n * @param block \n * @returns An array of 0, 1, or 2+ args\n */\nexport const extractArgs = <Fn extends BlockOperation>(block: BlockMetadata<Fn>) => {\n  const argKey: ValidKey<OneArgBlock> = \"arg\";\n  const argsKey: ValidKey<MultipleArgsBlock> = \"args\";\n  if (argKey in block && block[argKey]) return [(block as OneArgBlock).arg];\n  if (argsKey in block && (block[argsKey]?.length ?? 0) > 0) return (block as MultipleArgsBlock).args;\n  return [];\n}\n\n/**\n * Combine arguments' type, name, and handler information into a single structure\n * @param args \n * @param names \n * @returns \n */\nexport const zipArgs = (args: readonly Argument<any>[], names?: string[]) => {\n  const types = args.map(getArgumentType);\n  const handlers = extractHandlers(args);\n  names ??= types.map((_, index) => getArgName(index));\n  assertSameLength(types, handlers, names);\n  return types.map((type, index) => ({ type, name: names[index], handler: handlers[index] }));\n}\n\nexport const convertToArgumentInfo = (opcode: string, args: readonly Argument<any>[], menus: Menu<any>[]) => {\n  if (!args || args.length === 0) return undefined;\n\n  return Object.fromEntries(\n    args\n      .map((element, index) => {\n        if (isInlineImage(element)) return { ...element, dataURI: element.uri };\n\n        const entry = {} as ExtensionArgumentMetadata;\n        entry.type = getArgumentType(element);\n\n        if (isPrimitive(element)) return entry;\n\n        const { defaultValue, options } = element as VerboseArgument<any>;\n\n        setDefaultValue(entry, opcode, index, defaultValue);\n        setMenu(entry, options, menus);\n\n        return entry;\n      })\n      .reduce(\n        (accumulation, entry, index) => accumulation.set(getArgName(index), entry),\n        new Map<string, ExtensionArgumentMetadata>\n      )\n  );\n}\n\nconst getArgTranslationID = (blockname: string, index: number) => `${blockname}-arg${index}-default`;\n\nconst getDefaultValue = (defaultValue: any, opcode: string, index: number) => isString(defaultValue)\n  ? format(defaultValue, getArgTranslationID(opcode, index), `Default value for arg ${index + 1} of ${opcode} block`)\n  : defaultValue;\n\nconst setDefaultValue = (entry: ExtensionArgumentMetadata, opcode: string, index: number, defaultValue: any,) => {\n  if (defaultValue === undefined) return;\n  entry.defaultValue = getDefaultValue(defaultValue, opcode, index)\n}\n\nconst isInlineImage = (arg: Argument<any>): arg is InlineImage => !isString(arg) && arg.type === ArgumentType.Image;","import { AnyBlock, OneArgBlock, MultipleArgsBlock, Argument } from \"$common/types\";\nimport { isString } from \"$common/utils\";\nimport { getArgName } from \"./args\";\nimport { format } from \"./util\";\n\nconst isDynamicText = (text: AnyBlock[\"text\"]): text is (OneArgBlock[\"text\"] | MultipleArgsBlock[\"text\"]) => !isString(text);\n\nexport const convertToDisplayText = (opcode: string, text: AnyBlock[\"text\"], args: readonly Argument<any>[]) => {\n  if (!args || args.length === 0) return text as string;\n\n  if (!isDynamicText(text)) return format(text, opcode, `Block text for '${opcode}'`);\n\n  const textFunc: (...args: any[]) => string = text;\n  const argPlaceholders = args.map((_, index) => `[${getArgName(index)}]`);\n  return format(textFunc(...argPlaceholders), opcode, `Block text for '${opcode}'`);\n}","import { castToType } from \"$common/cast\";\nimport CustomArgumentManager from \"$common/extension/mixins/configurable/customArguments/CustomArgumentManager\";\nimport { ArgumentType, BlockType } from \"$common/types/enums\";\nimport { BlockOperation, ValueOf, Menu, ExtensionMetadata, ExtensionBlockMetadata, ExtensionMenuMetadata, DynamicMenu, BlockMetadata, BlockUtilityWithID, VersionedOptions } from \"$common/types\";\nimport { registerButtonCallback } from \"$common/ui\";\nimport { isString, typesafeCall, } from \"$common/utils\";\nimport { menuProbe, asStaticMenu, getMenuName, convertMenuItemsToString } from \"./menus\";\nimport { Handler } from \"./handlers\";\nimport { BlockDefinition, getButtonID, isBlockGetter } from \"./util\";\nimport { convertToArgumentInfo, extractArgs, zipArgs } from \"./args\";\nimport { convertToDisplayText } from \"./text\";\nimport { CustomizableExtensionConstructor, BaseScratchExtensionInstance, } from \"..\";\nimport { ExtensionInstanceWithFunctionality } from \"../..\";\nimport { blockIDKey } from \"$common/globals\";\n\nexport const getImplementationName = (opcode: string) => `internal_${opcode}`;\n\nconst inlineImageAccessError = \"ERROR: This argument represents an inline image and should not be accessed.\";\n\nconst isBlockUtilityWithID = (query: any): query is BlockUtilityWithID => query?.[blockIDKey] !== undefined;\nconst nonBlockContextError = \"Block method was not given a block utility, and thus was likely called by something OTHER THAN the Scratch Runtime. NOTE: You cannot call block methods directly from within your class due to how block methods are converted to work with scratch. Consider abstracting the logic to a seperate, non-block method which can be invoked directly.\"\nconst checkForBlockContext = (blockUtility: BlockUtilityWithID) => isBlockUtilityWithID(blockUtility) ? void 0 : console.error(nonBlockContextError);\n\n\n/**\n * Wraps a blocks operation so that the arguments passed from Scratch are first extracted and then passed as indices in a parameter array.\n * @param _this What will be bound to the 'this' context of the underlying operation\n * @param operation The operation (function) to wrap\n * @param args The args that must be parsed before being passed to the underlying operation \n * @returns \n */\nexport const wrapOperation = <T extends BaseScratchExtensionInstance>(\n  _this: T,\n  operation: BlockOperation,\n  args: { name: string, type: ValueOf<typeof ArgumentType>, handler: Handler }[]\n) => _this.supports(\"customArguments\")\n    ? function (this: ExtensionInstanceWithFunctionality<[\"customArguments\"]>, argsFromScratch: Record<string, any>, blockUtility: BlockUtilityWithID) {\n      checkForBlockContext(blockUtility);\n      const castedArguments = args.map(({ name, type, handler }) => {\n        if (type === ArgumentType.Image) return inlineImageAccessError;\n        const param = argsFromScratch[name];\n        switch (type) {\n          case ArgumentType.Custom:\n            const isIdentifier = isString(param) && CustomArgumentManager.IsIdentifier(param);\n            const value = isIdentifier ? this.customArgumentManager.getEntry(param).value : param;\n            return handler.call(_this, value);\n          default:\n            return castToType(type, handler.call(_this, param));\n        }\n      });\n      return operation.call(_this, ...castedArguments, blockUtility);\n    }\n    : function (this: T, argsFromScratch: Record<string, any>, blockUtility: BlockUtilityWithID) {\n      checkForBlockContext(blockUtility);\n      const castedArguments = args.map(({ name, type, handler }) =>\n        type === ArgumentType.Image\n          ? inlineImageAccessError\n          : castToType(type, handler.call(_this, argsFromScratch[name]))\n      );\n      return operation.call(_this, ...castedArguments, blockUtility);\n    }\n\n/**\n * Mixin the ability for extension's to:\n * - build up block definitions incrementally (through the use of `pushBlock`)\n * - implement a valid `getInfo` method that interacts with the scratch-vm correctly  \n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function (Ctor: CustomizableExtensionConstructor) {\n  type BlockEntry = { definition: BlockDefinition<ScratchExtension, BlockOperation>, operation: BlockOperation };\n  type BlockMap = Map<string, BlockEntry>;\n  type VersionMap = Map<string, VersionedOptions[]>;\n  abstract class ScratchExtension extends Ctor {\n    private readonly blockMap: BlockMap = new Map();\n    private readonly versionMap: VersionMap = new Map();\n\n    private readonly menus: Menu<any>[] = [];\n    private info: ExtensionMetadata;\n\n    /**\n     * Add a block \n     * @param opcode \n     * @param definition \n     * @param operation \n     */\n    pushBlock<Fn extends BlockOperation>(opcode: string, definition: BlockDefinition<any, Fn>, operation: BlockOperation) {\n      if (this.blockMap.has(opcode)) throw new Error(`Attempt to push block with opcode ${opcode}, but it was already set. This is assumed to be a mistake.`)\n      this.blockMap.set(opcode, { definition, operation } as BlockEntry);\n    }\n\n    pushVersions(opcode: string, versions: any) {\n      if (this.versionMap.has(opcode)) throw new Error(`Attempt to push block with opcode ${opcode}, but it was already set. This is assumed to be a mistake.`)\n      this.versionMap.set(opcode, versions);\n    }\n\n    getVersion(opcode: string) {\n      return this.versionMap.get(opcode);\n    }\n\n    getVersionMap() {\n      return this.versionMap;\n    }\n\n    protected getInfo(): ExtensionMetadata {\n      if (!this.info) {\n        const { id, name, blockIconURI } = this;\n        const blocks = Array.from(this.blockMap.entries()).map(entry => this.convertToInfo(entry));\n        const color1 = this.blockColor;\n        const color2 = this.menuColor;\n        const color3 = this.menuSelectColor;\n        this.info = { id, blocks, name, blockIconURI, menus: this.collectMenus(), color1, color2, color3 };\n      }\n      return this.info;\n    }\n\n    private convertToInfo(details: [opcode: string, entry: BlockEntry]) {\n      const [opcode, entry] = details;\n      const { definition, operation } = entry;\n\n      // Utilize explicit casting to appease test framework's typechecker\n      const block = isBlockGetter(definition)\n        ? typesafeCall(definition, this, this) as BlockMetadata<BlockOperation>\n        : definition as BlockMetadata<BlockOperation>;\n\n      const { type, text } = block;\n\n      const args = extractArgs(block);\n\n      const { id, runtime, menus } = this;\n\n      const displayText = convertToDisplayText(opcode, text, args);\n      const argumentsInfo = convertToArgumentInfo(opcode, args, menus);\n\n      const info: ExtensionBlockMetadata = { opcode, text: displayText, blockType: type, arguments: argumentsInfo };\n\n      if (type === BlockType.Button) {\n        const buttonID = getButtonID(id, opcode);\n        registerButtonCallback(runtime, buttonID, operation.bind(this));\n        info.func = buttonID;\n      } else {\n        const implementationName = getImplementationName(opcode);\n        this[implementationName] = wrapOperation(this as BaseScratchExtensionInstance, operation, zipArgs(args));\n      }\n\n      return info;\n    }\n\n    private collectMenus() {\n      const { isSimpleStatic, isSimpleDynamic, isStaticWithReporters, isDynamicWithReporters } = menuProbe;\n      return Object.fromEntries(\n        this.menus\n          .map((menu, index) => {\n            if (isSimpleStatic(menu)) return asStaticMenu(menu, false);\n            if (isSimpleDynamic(menu)) return this.registerDynamicMenu(menu, false, index);\n            if (isStaticWithReporters(menu)) return asStaticMenu(menu.items, true);\n            if (isDynamicWithReporters(menu)) return this.registerDynamicMenu(menu.getItems, true, index);\n            throw new Error(\"Unable to process menu\");\n          })\n          .reduce((map, menu, index) => map.set(getMenuName(index), menu), new Map<string, ExtensionMenuMetadata>())\n      );\n    }\n\n    private registerDynamicMenu(getItems: DynamicMenu<any>, acceptReporters: boolean, menuIndex: number) {\n      const key = `internal_dynamic_${menuIndex}`; // legacy support?\n      this[key] = () => getItems.call(this).map(item => item).map(convertMenuItemsToString);\n      return { acceptReporters, items: key } satisfies ExtensionMenuMetadata\n    }\n  }\n\n  return ScratchExtension;\n}","import type BlockUtility from \"$scratch-vm/engine/block-utility\";\nimport { TypedClassDecorator, TypedGetterDecorator, TypedMethodDecorator, TypedSetterDecorator } from \".\";\nimport { BlockType } from \"$common/types/enums\";\nimport { BlockMetadata, ScratchArgument, Argument, NoArgsBlock, VersionedOptions } from \"$common/types\";\nimport { getImplementationName } from \"../mixins/base/scratchInfo/index\";\nimport { ExtensionInstance } from \"..\";\nimport { isFunction, isString, tryCreateBundleTimeEvent } from \"$common/utils\";\nimport { extractArgs } from \"../mixins/base/scratchInfo/args\";\n\ntype BlockFunctionMetadata = {\n  methodName: string,\n  scratchType: string,\n  args: string[],\n  returns: string,\n}\n\nexport const blockBundleEvent = tryCreateBundleTimeEvent<BlockFunctionMetadata>(\"blocks\");\n\n\nexport const getAccessorPrefix = \"__getter__\";\nexport const setAccessorPrefix = \"__setter__\";\n\n/**\n * This a decorator function that should be associated with methods of your Extension class, all in order to turn your class methods\n * into Blocks that can be executed in the Block Programming Environment.\n * @param {BlockMetadata} blockInfoOrGetter Either an object or a function that returns an object of the following specified shapes \n * (which shape is required depends on your method's argument(s)):\n * @example \n * Block method accepts no arguments\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: string // the display text of your block\n * }\n * ```\n * @example \n * Block method accepts one argument\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: (arg) => string, // a function that returns a string, hover over the 'text' field in your code for more thourough documentation\n *  arg: Argument, // hover over the 'arg' field in your code for more thourough documentation\n * }\n * ```\n* @example \n * Block method accepts 2 or more arguments\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: (...args) => string, // a function that returns a string, hover over the 'text' field in your code for more thourough documentation\n *  args: Argument[], // hover over the 'args' field in your code for more thourough documentation\n * }\n * ```\n * @returns A manipulated version of the original method that is\n */\n\nexport function block<\n  const This extends ExtensionInstance,\n  const Args extends any[],\n  const Return,\n  const Fn extends (...args: Args) => Return,\n  const TRemoveUtil extends any[] = Args extends [...infer R extends any[], BlockUtility] ? R : Args,\n>\n  (\n    blockInfoOrGetter: (BlockMetadata<(...args: TRemoveUtil) => Return> | ((this: This, self: This) => BlockMetadata<(...args: TRemoveUtil) => Return>))\n  ): TypedMethodDecorator<This, Args, Return, (...args: Args) => Return> {\n\n  return function (this: This, target: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext<This, Fn>) {\n    const opcode = target.name;\n    const internalFuncName = getImplementationName(opcode);\n    // could add check for if this block is meant for scratch\n    context.addInitializer(function () { this.pushBlock(opcode, blockInfoOrGetter, target) });\n\n    const isProbableAtBundleTime = !isFunction(blockInfoOrGetter);\n    if (isProbableAtBundleTime) {\n      const { type } = blockInfoOrGetter;\n      blockBundleEvent?.fire({\n        methodName: opcode,\n        args: extractArgs(blockInfoOrGetter).map(a => isString(a) ? a : a.type),\n        // is 'any' an issue? Likely!\n        returns: type === \"command\" ? \"void\" : type === \"Boolean\" ? \"bool\" : \"any\",\n        scratchType: blockInfoOrGetter.type\n      });\n    }\n\n    return (function () { return this[internalFuncName].call(this, ...arguments) });\n  };\n}\n\nexport function versions<\n  const This extends ExtensionInstance,\n  const Args extends any[],\n  const Return,\n  const Fn extends (...args: Args) => Return,\n>\n  (\n    config: VersionedOptions[]\n  ): TypedMethodDecorator<This, Args, Return, (...args: Args) => Return> {\n\n  return function (this: This, target: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext<This, Fn>) {\n    context.addInitializer(function () { this.pushVersions(target.name, config); });\n    //\n    return target;\n  };\n}\n\n/**\n * This is a short-hand for invoking the block decorator when your `blockType` is button\n * @param text \n * @returns \n * @see {@link block} \n * @example\n * // Ignore the leading \"_\"\n * _@buttonBlock(\"The text of button block\")\n * buttonMethod() {\n *    this.openUI(\"someUI\")\n * }\n * \n */\nexport function buttonBlock<\n  This extends ExtensionInstance,\n>(text: string): TypedMethodDecorator<This, [], void, () => void> {\n  type Args = [] | [BlockUtility];\n  type Return = void;\n  type Fn = (...args: Args) => Return;\n\n  return block<This, Args, Return, Fn>({\n    text,\n    type: BlockType.Button\n  });\n}\n\nexport type PropertyBlockDetails<T> = {\n  /** \n   * The name of the property, which is both displayed to the user and used to associate the getter and setter blocks.\n   * \n   * **NOTE:** Associated getter and setter blocks should use the same `name`. Thus, it is best practice to define this name as a constant. \n  */\n  name: string,\n  /**\n   * The type of property \n   */\n  type: ScratchArgument<T>\n};\n\n/**\n * A block decorator for creating a reporer block out of a `get` accessor / \"getter\" property.\n * \n * @see https://www.typescriptlang.org/docs/handbook/classes.html#accessors \n * @param details \n * @returns \n */\nexport function getterBlock<This extends ExtensionInstance, TReturn>\n  (details: PropertyBlockDetails<TReturn>): TypedGetterDecorator<This, TReturn> {\n  return function (this: This, target: (this: This) => TReturn, context: ClassGetterDecoratorContext<This, TReturn>) {\n    const opcode = target.name.replace(\"get \", getAccessorPrefix);\n    const internalFuncName = getImplementationName(opcode);\n\n    context.addInitializer(function () {\n      this[opcode] = (_, util) => this[internalFuncName].call(this, null, util);;\n      const text = `Get ${details.name}`;\n      this.pushBlock(opcode, ({ type: \"reporter\", text } satisfies NoArgsBlock) as any, target);\n    });\n\n    blockBundleEvent?.fire({\n      methodName: opcode,\n      args: [],\n      returns: details.type,\n      scratchType: \"reporter\"\n    });\n  }\n}\n\n/**\n * A block decorator for creating a command block out of a `set` accessor / \"setter\" property.\n * \n * @param details \n * @returns \n */\nexport function setterBlock<This extends ExtensionInstance, TValue>\n  (details: PropertyBlockDetails<TValue>): TypedSetterDecorator<ExtensionInstance, TValue> {\n  return function (this: This, target: (this: This, value: TValue) => void, context: ClassSetterDecoratorContext<This, TValue>) {\n    const opcode = target.name.replace(\"set \", setAccessorPrefix);\n    const internalFuncName = getImplementationName(opcode);\n\n    context.addInitializer(function () {\n      this[opcode] = (args, util) => this[internalFuncName].call(this, args, util);\n      const text = (value: TValue) => `Set ${details.name} to ${value}`;\n      const arg = details.type as Argument<TValue>;\n      type Fn = (this: This, value: any, util: BlockUtility) => void;\n      const blockInfo = { type: BlockType.Command, text, arg } as BlockMetadata<Fn>;\n      this.pushBlock<Fn>(opcode, blockInfo, target);\n    });\n\n    blockBundleEvent?.fire({\n      methodName: opcode,\n      args: [details.type],\n      returns: \"void\",\n      scratchType: \"command\"\n    });\n  }\n}","import { legacySupportWithInfoArgument } from \"$common/extension/mixins/configurable/legacySupport\";\nimport { ExtensionMetadata, ExtensionBlockMetadata, ExtensionMenuItems, BlockOperation, Argument, ExtensionMenuMetadata, ExtensionDynamicMenu, Menu, DynamicMenuThatAcceptsReporters, BaseGenericExtension, VerboseArgument, DefineBlock, AbstractConstructor, NonAbstractConstructor, BlockMetadata, NoArgsBlock, OneArgBlock } from \"$common/types\";\nimport { isFunction, isString } from \"$common/utils\";\nimport { block } from \"../blocks\";\nimport { ArgumentMethods, BlockDecorators, BlockDefinitions, BlockEntry, BlockMap, LegacyExtension, LegacyExtensionDecorator, LegacySupport, ObjectOrGetter } from \"./types\";\nimport { ExtensionInstance } from \"$common/extension\";\n\n/**\n * \n * @param info \n * @param flags \n * @returns \n */\nexport const legacy = <\n  const TInfo extends ExtensionMetadata,\n  TFlags extends { incrementalDevelopment: boolean } = undefined,\n  const TStrict extends boolean = TFlags extends { incrementalDevelopment: false } | undefined ? true : false\n>(info: TInfo, flags?: TFlags): LegacySupport<TInfo, TStrict> => ({\n\n  for<TExtension extends LegacyExtension<TInfo, TStrict>>() {\n\n    const legacyExtension = (): LegacyExtensionDecorator<TExtension> => (value, context) => {\n      abstract class LegacySupport extends legacySupportWithInfoArgument(value as AbstractConstructor<ExtensionInstance>, info) {\n        readonly originalClassName = context.name;\n      };\n\n      return LegacySupport as AbstractConstructor<ExtensionInstance> as NonAbstractConstructor<TExtension>;\n    };\n\n    const blockMethodBroker = getBlockMetaData(info).map(([opcode, entry]) => {\n      const key = opcode as keyof BlockDefinitions<TInfo, TExtension>;\n      return {\n        key,\n        definer: createBlockDefiner<TExtension & BaseGenericExtension>(entry),\n        decorator: createBlockDecorator<TExtension & ExtensionInstance>(entry)\n      }\n    });\n\n    const legacyDefinition = blockMethodBroker.reduce((definitions, { key, definer }) => {\n      definitions[key] = definer as any; // TODO: See if we can get this type to work\n      return definitions;\n    }, {} as BlockDefinitions<TInfo, TExtension>);\n\n\n    const legacyBlock = blockMethodBroker.reduce((decorators, { key, decorator }) => {\n      decorators[key] = decorator as any; // TODO: See if we can get this type to work\n      return decorators;\n    }, {} as BlockDecorators<TInfo>);\n\n    const throwTypeOnlyError = () => {\n      throw new Error(\"This property is not meant to be accessed, and is instead solely for type inference / documentation purposes.\")\n    };\n\n    return {\n      legacyExtension, legacyDefinition, legacyBlock,\n      ReservedNames: {\n        get Menus(): any { return throwTypeOnlyError() },\n        get Blocks(): any { return throwTypeOnlyError() },\n        get ArgumentNamesByBlock(): any { return throwTypeOnlyError() },\n      },\n    };\n  }\n})\n\n/**\n * Creates a function that returns a function that acts as a block definition for the 'entry' block metadata.\n * @param entry \n * @returns \n */\nconst createBlockDefiner = <TExtension extends ExtensionInstance & BaseGenericExtension>(entry: BlockEntry) =>\n  (objOrGetter: ObjectOrGetter<{ opertation: BlockOperation } & Partial<ArgumentMethods<any, any>>, TExtension>) =>\n    ((extension: TExtension) => {\n      const { operation, argumentMethods } = isFunction(objOrGetter) ? objOrGetter.call(extension, extension) : objOrGetter;\n      if (argumentMethods) attachArgumentMethods(entry, argumentMethods, extension);\n      return { ...entry, operation }\n    }) as DefineBlock<TExtension, BlockOperation>;\n\n/**\n * Creates a function that returns a decorator function that wraps the data contained within 'entry'.\n * @param entry \n * @returns \n */\nconst createBlockDecorator = <TExtension extends ExtensionInstance>(entry: BlockEntry) =>\n  (...params: ([ObjectOrGetter<ArgumentMethods<any, any>, TExtension>] | [])) => {\n    if (params.length === 0 || !params[0]) return block<TExtension, any[], any, any>(entry as BlockMetadata<any>);\n    const objOrGetter = params[0];\n    return block<TExtension, any[], any, any>((extension: TExtension) => {\n      const { argumentMethods } = isFunction(objOrGetter)\n        ? objOrGetter.call(extension, extension) : objOrGetter;\n\n      attachArgumentMethods(entry, argumentMethods, extension);\n      return entry as BlockMetadata<any>;\n    });\n  }\n\nconst attachArgumentMethods = (\n  block: ReturnType<BlockMap[\"get\"]>,\n  argumentMethods: Record<number, Partial<DynamicMenuThatAcceptsReporters<unknown>>>,\n  extension: ExtensionInstance\n) => {\n  const args = block.args ? block.args : block.arg ? [block.arg] : [];\n\n  Object.entries(argumentMethods)\n    .map(([indexKey, { handler, getItems }]) => {\n      const arg = args[parseInt(indexKey)] as VerboseArgument<any>;\n      return { arg, methods: { handler, getItems } }\n    })\n    .forEach(({ arg, methods }) =>\n      Object.entries(methods)\n        .filter(([_, method]) => method !== undefined)\n        .map(([key, method]) => [key, method.bind(extension)])\n        .forEach(([key, method]) => tryUpdateKey(arg, key, method)))\n}\n\nconst tryUpdateKey = <T extends Menu<any>>(arg: VerboseArgument<any>, key: string, value: T) => {\n  if (isFunction(arg.options)) arg.options = value;\n  arg.options[key] = value;\n}\n\nconst asBlockMetaData = (block: ExtensionBlockMetadata | string) => {\n  if (isString(block)) throw new Error(`Block defined as string, unexpected! ${block}`)\n  return block as ExtensionBlockMetadata;\n}\n\nconst convertAndInsertBlock = (map: BlockMap, block: ExtensionBlockMetadata, metadata: ExtensionMetadata) => {\n  const { opcode, arguments: _arguments, blockType: type } = block;\n  const { text, orderedNames } = parseText(block);\n\n  if (!_arguments) {\n    if (typeof text !== \"string\") throw new Error(`Text is not a string: ${text}`);\n    return map.set(opcode, ({ type, text } satisfies NoArgsBlock) as BlockEntry);\n  }\n\n  const args = Object.entries(_arguments ?? {})\n    .map(([name, { menu, ...rest }]) => ({ options: extractMenuOptions(metadata, menu), name, menu, ...rest }))\n    .sort(({ name: a }, { name: b }) => orderedNames.indexOf(a) < orderedNames.indexOf(b) ? -1 : 1)\n    .map(({ name, ...details }) => details satisfies Argument<any> as Argument<unknown>);\n\n  const { length } = args;\n  return length >= 2\n    ? map.set(opcode, { type, text, args } as any)\n    : map.set(opcode, ({ type, text: text as OneArgBlock[\"text\"], arg: args[0] } satisfies OneArgBlock) as any)\n}\n\nconst getBlockMetaData = (metadata: ExtensionMetadata) => Array.from(\n  metadata.blocks\n    .map(asBlockMetaData)\n    .reduce((map, block) => convertAndInsertBlock(map, block, metadata), new Map() as BlockMap)\n    .entries()\n);\n\nexport const parseText = ({ arguments: _arguments, text }: ExtensionBlockMetadata) => {\n  const placeholder = \"Error: This should have been overridden by legacy support\";\n\n  if (!_arguments) return { orderedNames: null as null, text: placeholder };\n\n  const args = Object.keys(_arguments)\n    .map(name => ({ name, template: `[${name}]` }))\n    .sort(({ template: a }, { template: b }) => text.indexOf(a) < text.indexOf(b) ? -1 : 1);\n\n  return args.length === 0\n    ? { orderedNames: null as null, text: placeholder }\n    : { orderedNames: args.map(({ name }) => name), text: () => placeholder }\n}\n\nconst getItemsPlaceholder = { getItems: () => (\"Error: This should have been filled in.\" as any) };\nconst handlerPlaceholder = { handler: () => (\"Error: This should have been filled in.\" as any) };\n\nexport const isDynamicMenu = (menu: ExtensionMenuMetadata | ExtensionMenuItems[\"items\"]): menu is ExtensionDynamicMenu => isString(menu);\n\nconst extractMenuOptions = (data: ExtensionMetadata, menuName: string): Menu<any> => {\n  const menu = menuName ? data.menus[menuName] : undefined;\n\n  if (!menu) return undefined;\n  if (isDynamicMenu(menu)) return getItemsPlaceholder.getItems;\n\n  const { items, acceptReporters: acceptsReporters } = menu;\n\n  if (!isDynamicMenu(items)) return acceptsReporters ? { acceptsReporters, items: [...items], ...handlerPlaceholder } : [...items];\n\n  return acceptsReporters ? { acceptsReporters, ...handlerPlaceholder, ...getItemsPlaceholder } : getItemsPlaceholder.getItems;\n}","import { ExtensionInstance } from \"$common/extension\";\nimport { AbstractConstructor, ExtensionArgumentMetadata, ExtensionBlockMetadata, ExtensionMenuMetadata, ExtensionMetadata } from \"$common/types\";\nimport { isString, set } from \"$common/utils\";\nimport { isDynamicMenu, parseText } from \"../../decorators/legacySupport/index\";\nimport { MinimalExtensionConstructor } from \"../base\";\nimport { getImplementationName, wrapOperation } from \"../base/scratchInfo/index\";\n\ntype WrappedOperation = ReturnType<typeof wrapOperation>;\ntype WrappedOperationParams = Parameters<WrappedOperation>;\ntype WithLegacySupport = InstanceType<ReturnType<typeof legacySupportMixin>>;\ntype BlockMap = Map<string, Omit<ExtensionBlockMetadata, \"opcode\"> & { index: number }>;\n\nexport const isLegacy = (extension: ExtensionInstance | WithLegacySupport): extension is WithLegacySupport => {\n  const key: keyof WithLegacySupport = \"__isLegacy\";\n  return key in extension;\n}\n\nconst validBlock = (legacyBlock: string | ExtensionBlockMetadata, blockMap: BlockMap): legacyBlock is ExtensionBlockMetadata => {\n  if (isString(legacyBlock)) throw new Error(\"Block was unexpectedly a string: \" + legacyBlock);\n  if (!blockMap.has(legacyBlock.opcode)) {\n    console.error(`Could not find legacy opcode ${legacyBlock.opcode} within currently defined blocks`);\n    return false;\n  };\n  return true;\n}\n\nconst validArg = (pair: { legacy: ExtensionArgumentMetadata, modern: ExtensionArgumentMetadata }): typeof pair => {\n  if (typeof pair.legacy.menu !== typeof pair.modern.menu) throw new Error(\"Menus don't match\")\n  return pair;\n}\n\nconst getDynamicMenuName = (menu: ExtensionMenuMetadata): string => {\n  if (isDynamicMenu(menu)) return menu;\n  if (isDynamicMenu(menu.items)) return menu.items;\n  throw new Error(\"Menu is not dynamic: \" + menu);\n}\n\n/**\n * Mixin the ability for extensions to make use of 'legacy' `getInfo` json, \n * so that extensions ported to the framework can support old, serialized projects\n * @param Ctor \n * @param legacyInfo \n * @returns \n */\nexport default function legacySupportMixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithLegacySupport extends Ctor {\n    private validatedInfo: ExtensionMetadata;\n\n    protected abstract getLegacyInfo(): ExtensionMetadata;\n\n    public __isLegacy = true;\n    public orderArgumentNamesByBlock: Map<string, string[]> = new Map();\n\n    protected override getInfo(): ExtensionMetadata {\n      if (!this.validatedInfo) {\n        const info = super.getInfo();\n        this.validatedInfo = this.validateAndAttach(info);\n      }\n\n      return this.validatedInfo;\n    }\n\n    private getArgNames = (legacyBlock: ExtensionBlockMetadata) => {\n      const { opcode } = legacyBlock;\n\n      if (!this.orderArgumentNamesByBlock.has(opcode)) {\n        const { orderedNames } = parseText(legacyBlock);\n        this.orderArgumentNamesByBlock.set(opcode, orderedNames);\n      }\n\n      return this.orderArgumentNamesByBlock.get(opcode);\n    }\n\n    private validateAndAttach({ id, blocks, menus, ...metaData }: ExtensionMetadata): ExtensionMetadata {\n      const { id: legacyID, blocks: legacyBlocks, menus: legacyMenus } = this.getLegacyInfo();\n      const mutableBlocks = [...blocks as ExtensionBlockMetadata[]];\n\n      if (id !== legacyID) throw new Error(`ID mismatch! Legacy id: ${legacyID} vs. current id: ${id}`);\n\n      const blockMap = mutableBlocks.reduce(\n        (map, { opcode, ...block }, index) => map.set(opcode, { ...block, index }),\n        new Map() as BlockMap\n      );\n\n      const self = this;\n\n      const updates = legacyBlocks\n        .map(legacyBlock => validBlock(legacyBlock, blockMap) ? legacyBlock : undefined)\n        .filter(Boolean)\n        .map(legacyBlock => {\n          const { opcode, arguments: legacyArgs } = legacyBlock;\n          const { index, arguments: modernArgs } = blockMap.get(opcode);\n          const argNames = this.getArgNames(legacyBlock);\n\n          if (!argNames) return { replaceAt: { index, block: legacyBlock } };\n\n          const remapper = (args: Record<string, any>) => argNames.reduce(\n            (remap, current, index) => set(remap, index, args[current]),\n            {} as Record<number, any>);\n\n          const implementation: WrappedOperation = this[getImplementationName(opcode)];\n\n          this[opcode] = (\n            (...[args, util]: WrappedOperationParams) => implementation.call(self, remapper(args), util)\n          ).bind(self);\n\n          const menuUpdates = argNames\n            .map((legacyName, index) => ({ legacy: legacyArgs[legacyName], modern: modernArgs[index] }))\n            .map(validArg)\n            .map(({ legacy: { menu: legacyName }, modern: { menu: modernName } }) => ({ legacyName, modernName }))\n            .filter(menus => menus.legacyName && menus.modernName)\n            .map(({ legacyName, modernName }) =>\n              ({ legacyName, modernName, legacy: legacyMenus[legacyName], modern: menus[modernName] }))\n            .map(({ legacy, modern, legacyName, modernName }) => !isDynamicMenu(legacy) && !isDynamicMenu(legacy.items)\n              ? { type: \"static\" as const, legacy: legacyName, modern: modernName }\n              : { type: \"dynamic\" as const, legacy: legacyName, modern: modernName, methods: { legacy: getDynamicMenuName(legacy), modern: getDynamicMenuName(modern) } }\n            );\n\n          return { menuUpdates, replaceAt: { index, block: legacyBlock } };\n        });\n\n      updates.forEach(({ replaceAt: { index, block } }) => {\n        const current = mutableBlocks[index];\n        mutableBlocks[index] = block;\n        if (block.blockType === \"button\") mutableBlocks[index].func = current.func;\n      });\n\n      updates\n        .map(({ menuUpdates }) => menuUpdates)\n        .flat()\n        .filter(Boolean)\n        .map(menu => {\n          const { legacy } = menu;\n          if (legacy in menus) throw new Error(`Somehow, there was already a menu called ${legacy}, which will cause issues in the next step.`);\n          return menu;\n        })\n        .forEach(({ type, legacy, methods }) => {\n          menus[legacy] = legacyMenus[legacy];\n          if (type === \"dynamic\") self[methods.legacy] = () => self[methods.modern]();\n        });\n\n      return {\n        id, blocks: mutableBlocks, menus, ...metaData\n      };\n    }\n  }\n  return ExtensionWithLegacySupport\n}\n\n/**\n * Mixin the ability for extensions to make use of 'legacy' `getInfo` json, \n * so that extensions ported to the framework can support old, serialized projects\n * @param Ctor \n * @param legacyInfo \n * @returns \n */\nexport function legacySupportWithInfoArgument<T extends AbstractConstructor<ExtensionInstance>>(Ctor: T, legacyInfo: ExtensionMetadata) {\n  abstract class ExtensionWithLegacySupport extends legacySupportMixin(Ctor) {\n    protected getLegacyInfo() {\n      return legacyInfo;\n    }\n  }\n\n  return ExtensionWithLegacySupport\n}","import { ExtensionInstanceWithFunctionality } from \"../..\";\n\nexport const isSvgGroup = (element: Element): element is SVGGElement => element.nodeName === \"g\";\nexport const isSvgText = (element: Element): element is SVGTextElement => element.nodeName === \"text\";\n\ntype AlertType = Parameters<ExtensionInstanceWithFunctionality<[\"indicators\"]>[\"indicate\"]>[0][\"type\"];\n\nconst fills = {\n  success: \"#5ACA75\",\n  warning: \"#FF8f39\",\n  error: \"#db1f1f\"\n} satisfies Record<AlertType, string>;\n\nconst textAttributes = {\n  fill: \"white\",\n  \"font-weight\": \"bold\",\n  \"font-size\": \"14pt\",\n  \"font-family\": \"\\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\"\n}\n\nexport async function openAlert(container: SVGGElement, msg: string, type: AlertType) {\n  const elements = createElements();\n  const [rect, triangle, text] = elements;\n\n  const padding = 12;\n  const y = 55;\n  const x = 0;\n  const fill = fills[type];\n\n  applyAttributes(triangle, { points: equilateralTrianglePoints, fill });\n  applyAttributes(text, { x: x + padding / 2, y });\n  applyAttributes(text, textAttributes);\n\n  text.innerHTML = msg;\n\n  elements.forEach(el => container.appendChild(el));\n\n  await Promise.resolve(); // await for elements to render (is there a better way?)\n\n  const { width, height } = text.getBBox();\n  applyAttributes(rect, { x, width: width + padding, height: height + padding, y: y - height, fill, rx: 5 });\n\n  return {\n    close() { elements.forEach(element => container.removeChild(element)); }\n  };\n}\n\nconst applyAttributes = <T extends Record<string, any>>(element: Element, attributes: T) => {\n  for (const key in attributes) {\n    element.setAttribute(key, `${attributes[key]}`);\n  }\n}\n\nconst createElements = () => [createElement(\"rect\"), createElement(\"polygon\"), createElement(\"text\")] as const;\n\nconst createElement = <T extends \"text\" | \"rect\" | \"polygon\">(type: T) =>\n  document.createElementNS('http://www.w3.org/2000/svg', type);\n\nconst getEquilateralTrianglePoints = () => {\n  const reduction = { x: 5, y: 14 };\n  const shift = { x: 10, y: 26 };\n  return [[50, 15], [100, 100], [0, 100]]\n    .map(([x, y]) => [x / reduction.x + shift.x, y / reduction.y + shift.y])\n    .map(([x, y]) => `${x} ${y}`)\n    .join(\", \");\n}\n\nconst equilateralTrianglePoints = getEquilateralTrianglePoints();","import { untilTimePassed } from \"$common/utils\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport { isSvgGroup, isSvgText, openAlert } from \"./svgAlert\";\n\ntype IndicatorPayload = { position?: \"category\", msg: string, type?: \"success\" | \"warning\" | \"error\" };\n\n/**\n * Mixin the ability for extensions to add an indicator message to the workspace.\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionThatIndicates extends Ctor {\n    readonly IndicatorType: Required<IndicatorPayload>[\"type\"];\n\n    /**\n     * Add an indicator message to the workspace.\n     * @param param0 Details\n     * - `position`: Where to place the indicator. Currently only \"category\" is supported, which places the message immediately below the extensions name.\n     * - `msg`: The message to display.\n     * - `type`: The type of indicator to display. Currently \"success\", \"warning\" and \"error\", which effect the color of the indicator.\n     * @returns \n     */\n    async indicate({ position = \"category\", msg, type = \"success\" }: IndicatorPayload) {\n\n      const elements = position === \"category\"\n        ? getCategoryElements(this.name)\n        : { error: \"Unsupported indicator position\" };\n\n      if (\"error\" in elements) throw new Error(elements.error);\n      const { container } = elements;\n      const alert = await openAlert(container, msg, type);\n      return alert;\n    }\n\n    async indicateFor({ position = \"category\", msg, type = \"success\" }: IndicatorPayload, seconds: number) {\n      const { close } = await this.indicate({ position, msg, type });\n      await untilTimePassed(seconds * 1000);\n      close();\n    }\n  }\n\n  return ExtensionThatIndicates;\n}\n\nconst topLevelClass = \"blocklyFlyout\";\nconst containerClass = \"blocklyFlyoutLabel categoryLabel\";\nconst textClass = \"blocklyFlyoutLabelText\";\n\nconst getCategoryElements = (text: string): { error: string } | { container: SVGGElement, title: SVGTextElement } => {\n  const topLevel = document.body.getElementsByClassName(topLevelClass);\n  if (topLevel.length !== 1) return { error: \"No top level element found.\" };\n\n  for (const container of topLevel[0].getElementsByClassName(containerClass)) {\n    for (const title of container.getElementsByClassName(textClass)) {\n      if (title.innerHTML !== text || !isSvgGroup(container) || !isSvgText(title)) continue;\n      return { container, title };\n    }\n  }\n  return { error: \"No title found matching given name\" };\n}","import type Video from \"$scratch-vm/io/video\";\nimport { MinimalExtensionConstructor } from \"../base\";\n\nconst Format = {\n  image: \"image-data\",\n  canvas: \"canvas\"\n} as const satisfies {\n  image: (typeof Video)[\"FORMAT_IMAGE_DATA\"],\n  canvas: (typeof Video)[\"FORMAT_CANVAS\"];\n}\n\ntype VideoFrameTypeByFormat = {\n  \"image-data\": ImageData,\n  \"canvas\": HTMLCanvasElement\n}\n\n/**\n * Mixin the ability for extensions to interact with the user's web cam video feed\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithVideoSupport extends Ctor {\n    private videoDevice: Video | null;\n\n    private get video(): Video | null {\n      this.videoDevice ??= this.runtime.ioDevices?.video;\n      return this.videoDevice;\n    };\n\n    /**\n     * Dimensions of the video frame\n     */\n    videoDimensions = { width: 480, height: 360 } as const;\n\n    /**\n     * Access the most recent frame captured by the web cam\n     * @param {\"image\" | \"canvas\"} format \n     * @returns \n     */\n    getVideoFrame<TFormat extends keyof typeof Format>(format: TFormat) {\n      return this.video?.getFrame({\n        format: Format[format]\n      }) as VideoFrameTypeByFormat[typeof Format[typeof format]]\n    }\n\n    setVideoTransparency(transparency: number) {\n      this.video?.setPreviewGhost(transparency);\n    }\n\n    /**\n     * Turn the video feed on so that it's frames can be accessed and the feed\n     * diplays within the game window.\n     * @param {boolean} mirror defaults to `true`\n     * @returns \n     */\n    enableVideo(mirror: boolean = true) {\n      if (!this.video) return;\n      this.video.enableVideo();\n      this.video.provider.mirror = mirror;\n    }\n\n    /**\n     * Disable the video feed\n     */\n    disableVideo() {\n      this.video?.disableVideo();\n    }\n  }\n\n  return ExtensionWithVideoSupport;\n}\n","import { AbstractConstructor } from \"$common/types\";\nimport addCostumes from \"./configurable/addCostumes/index\";\nimport customArguments from \"./configurable/customArguments/index\";\nimport customSaveData from \"./configurable/customSaveData\";\nimport drawable from \"./configurable/drawable\";\nimport legacySupport from \"./configurable/legacySupport\";\nimport ui from \"./configurable/ui\";\nimport indicators from \"./configurable/indicators\";\nimport video from \"./configurable/video\";\nimport setTransparencyBlock from \"./configurable/blocks/setVideoTransparency\";\nimport toggleVideoBlock from \"./configurable/blocks/toggleVideoState\";\nimport appInventor from \"./configurable/appInventor/index\";\nimport { MinimalExtensionConstructor } from \"./base\";\n\nexport type Mixin<T> = (Ctor: MinimalExtensionConstructor) => AbstractConstructor<T>;\n\nexport const optionalMixins = {\n  customArguments,\n  ui,\n  customSaveData,\n  video,\n  drawable,\n  addCostumes,\n  legacySupport,\n  setTransparencyBlock,\n  toggleVideoBlock,\n  appInventor,\n  indicators,\n} as const satisfies OptionalMixins satisfies Record<string, Mixin<unknown>>;\n\nexport type OptionalMixins<T extends MinimalExtensionConstructor = MinimalExtensionConstructor> = {\n  ui: typeof ui<T>;\n  customArguments: typeof customArguments<T>,\n  customSaveData: typeof customSaveData<T>,\n  video: typeof video<T>,\n  drawable: typeof drawable<T>,\n  addCostumes: typeof addCostumes<T>,\n  legacySupport: typeof legacySupport<T>,\n  setTransparencyBlock: typeof setTransparencyBlock<T>,\n  toggleVideoBlock: typeof toggleVideoBlock<T>,\n  appInventor: typeof appInventor<T>,\n  indicators: typeof indicators<T>,\n}\n\nexport type MixinName = keyof typeof optionalMixins;\n\nexport type ExtensionWithFunctionality<TSupported extends MixinName[], TBase extends MinimalExtensionConstructor = MinimalExtensionConstructor> =\n  TSupported extends [infer Head, ...infer Tail]\n  /** Use `extends` to enable typescript to infer desired characteristics */\n  ? Head extends keyof OptionalMixins ? Tail extends (keyof OptionalMixins)[] ? TBase extends MinimalExtensionConstructor\n  /** Accumalate the TBase parameter */\n  ? ExtensionWithFunctionality<Tail, ReturnType<OptionalMixins<TBase>[Head]>>\n  /** Return never as Head, Tail, and TBase should never not meet the above type requirements */\n  : never : never : never\n  /** Base case */\n  : TBase;\n\nexport type ExtensionInstanceWithFunctionality<TSupported extends MixinName[]> = InstanceType<ExtensionWithFunctionality<TSupported>>;","import CustomArgumentManager from \"$common/extension/mixins/configurable/customArguments/CustomArgumentManager\";\nimport { ArgumentType } from \"$common/types/enums\";\nimport { guiDropdownInterop } from \"$common/globals\";\nimport { Argument, Expand } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport { withDependencies } from \"../../dependencies\";\nimport customSaveData from \"../customSaveData\";\nimport { ArgumentEntry, ArgumentID, CustomArgumentComponent, CustomArgumentRecipe, RuntimeWithCustomArgumentSupport, renderToDropdown } from \"./utils\";\nimport { ExtensionBase } from \"$common/extension/ExtensionBase\";\n\n/**\n * Mixin the ability for extensions to create custom argument types with their own specific UIs\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function mixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomArgumentSupport extends withDependencies(Ctor, customSaveData) {\n    private argumentManager: CustomArgumentManager = null;\n\n    /**\n     * Create a custom argument for one of this block's argument. Within the argument object, you must provide:\n     * - `component`: The svelte component to render (import it directly in your file)\n     * - `initial`: The arguments default value (you must provide both the value and the text representation)\n     */\n    protected makeCustomArgument = <T, TExtension extends ExtensionBase>({ component, initial, acceptReportersHandler: handler }: Expand<CustomArgumentRecipe<T, TExtension>>): Argument<T> => {\n      const id = this.customArgumentManager.add(initial);\n      const getItems = () => this.processMenuForCustomArgument(id, component);\n      return {\n        type: ArgumentType.Custom,\n        defaultValue: id,\n        options: handler === undefined ? getItems : { acceptsReports: true, getItems, handler },\n      } as Argument<T>\n    }\n\n    public get customArgumentManager(): CustomArgumentManager {\n      this.argumentManager ??= new CustomArgumentManager();\n      return this.argumentManager\n    }\n\n    private processMenuForCustomArgument(initialID: ArgumentID, Component: CustomArgumentComponent): (ArgumentEntry<any>)[] {\n      const { runtime, argumentManager } = this;\n      const interop = (runtime as RuntimeWithCustomArgumentSupport)[guiDropdownInterop.runtimeKey];\n\n      const { state, update, entry } = interop\n\n      switch (state) {\n        case \"init\":\n        case \"close\":\n          return argumentManager.entries;\n        case \"open\":\n          const id = entry?.value ?? initialID;\n          const current = argumentManager.getEntry(id);\n          const setter = argumentManager.request(id, update);\n          renderToDropdown(Component, { setter, current, extension: this });\n          return [{ text: current.text, value: id }];\n        case \"update\":\n          return [argumentManager.getCurrent()];\n      }\n    };\n\n  }\n  return ExtensionWithCustomArgumentSupport;\n}","import { openUI } from \"$common/ui\";\nimport { MinimalExtensionConstructor } from \"../base\";\n\n/**\n * Mixin the ability for extensions to open up UI at-will\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithUISupport extends Ctor {\n\n    /**\n     * Open a UI in a modal window \n     * @param component The name of the svelte component / file to open (which should be stored within the same folder as your extension's `index.ts` file). \n     * You can optionally leave off the `.svelte` extension.\n     * @param label What to title the modal window that pops up (defaults to your extension's name if left blank)\n     */\n    openUI(component: string, label?: string) {\n      const { id, name, runtime } = this;\n      openUI(runtime, { id, name, component: component.replace(\".svelte\", \"\"), label });\n    }\n\n  }\n\n  return ExtensionWithUISupport;\n}\n","import { StageLayering, ValueOf } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../base\";\n\ntype Handle = number;\n\ntype Renderer = {\n  /**\n   * Create a new bitmap skin from a snapshot of the provided bitmap data.\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n   * @param {!int} [costumeResolution=1] - The resolution to use for this bitmap.\n   * @param {?Array<number>} [rotationCenter] Optional: rotation center of the skin. If not supplied, the center of\n   * the skin will be used.\n   * @returns {!int} the ID for the new skin.\n   */\n  createBitmapSkin(bitmapData: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, costumeResolution?: number, rotationCenter?: Array<number> | null): Handle;\n  /**\n   * Create a new Drawable and add it to the scene.\n   * @param {string} group Layer group to add the drawable to\n   * @returns {int} The ID of the new Drawable.\n   */\n  createDrawable(group: string): Handle;\n  /**\n     * Update a drawable's visibility.\n     * @param {number} drawableID The drawable's id.\n     * @param {boolean} visible Will the drawable be visible?\n     */\n  updateDrawableVisible(drawableID: number, visible: boolean): void;\n  /**\n   * Update a drawable's visual effect.\n   * @param {number} drawableID The drawable's id.\n   * @param {string} effectName The effect to change.\n   * @param {number} value A new effect value.\n   */\n  updateDrawableEffect(drawableID: number, effectName: string, value: number): void;\n  /**\n   * Update a drawable's skin.\n   * @param {number} drawableID The drawable's id.\n   * @param {number} skinId The skin to update to.\n   */\n  updateDrawableSkinId(drawableID: Handle, skinId: Handle): void;\n  /**\n   * Update an existing bitmap skin, or create a bitmap skin if the previous skin was not bitmap.\n   * @param {!int} skinId the ID for the skin to change.\n   * @param {!ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imgData - new contents for this skin.\n   * @param {!number} bitmapResolution - the resolution scale for a bitmap costume.\n   * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n   * skin will be used\n   */\n  updateBitmapSkin(skinId: Handle, imgData: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, bitmapResolution: number, rotationCenter?: Array<number> | null): void;\n  /**\n   * Destroy an existing skin. Do not use the skin or its ID after calling this.\n   * @param {!int} skinId - The ID of the skin to destroy.\n   */\n  destroySkin(skinId: number): void;\n  /**\n   * Destroy a Drawable, removing it from the scene.\n   * @param {int} drawableID The ID of the Drawable to remove.\n   * @param {string} group Group name that the drawable belongs to\n   */\n  destroyDrawable(drawableID: Handle, group: string): void;\n}\n\n/**\n * Mixin the ability for extensions to draw images into the canvas\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithDrawingSupport extends Ctor {\n    private renderer: Renderer;\n\n    /**\n     * Draw an item on screen using image data\n     * @param {ImageData | ImageBitmap} image \n     * @returns \n     */\n    protected createDrawable<T extends ImageData | ImageBitmap>(image: T) {\n      this.renderer ??= this.runtime.renderer;\n      const { renderer } = this;\n\n      if (!renderer) return null;\n\n      const skin = renderer.createBitmapSkin(image as ImageData, 1);\n      const drawable = renderer.createDrawable(StageLayering.VideoLayer);\n\n      renderer.updateDrawableSkinId(drawable, skin);\n\n      const setTransparency = (transparency: number) =>\n        renderer.updateDrawableEffect(drawable, 'ghost', transparency);\n\n      const setVisible = (visible: boolean = true) =>\n        renderer.updateDrawableVisible(drawable, visible);\n\n      const update = (image: ImageData | ImageBitmap) =>\n        renderer.updateBitmapSkin(skin, image as ImageData, 1);\n\n      const destroy = () => {\n        setVisible(false);\n        renderer.destroyDrawable(drawable, StageLayering.VideoLayer);\n        renderer.destroySkin(skin);\n      }\n\n      setTransparency(0);\n      setVisible(true);\n\n      return { setTransparency, setVisible, update, destroy }\n    }\n  }\n\n  return ExtensionWithDrawingSupport;\n}\n","export const getUrlHelper = (dimensions: { width: number, height: number }) => {\n  const canvas = document.body.appendChild(document.createElement(\"canvas\"));\n\n  const setDimensions = ({ width, height }: Parameters<typeof getUrlHelper>[0]) => {\n    if (canvas.width !== width) canvas.width = width;\n    if (canvas.height !== height) canvas.height = height;\n  };\n\n  setDimensions(dimensions);\n\n  canvas.hidden = true;\n  const context = canvas.getContext(\"2d\");\n\n  return {\n    /**\n     * \n     * @param image \n     * @returns \n     */\n    getDataURL(image: ImageData) {\n      const { width, height } = image;\n      setDimensions(image);\n      context.save();\n      context.clearRect(0, 0, width, height);\n      context.putImageData(image, 0, 0);\n      const url = canvas.toDataURL('image/png');\n      context.restore();\n      return url;\n    }\n  }\n}","import { block } from \"$common/extension/decorators/blocks\";\nimport { withDependencies } from \"../../dependencies\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport video from \"../video\";\n\n/**\n * Mixin a 'setVideoTransparency' Block to control the transparency of the videofeed\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithSetVideoTransparencyBlock extends withDependencies(Ctor, video) {\n    /**\n     * A `command` block that takes a single number argument and uses it to set the transparency of the video feed.\n     * @param transparency What transparency to set -- a higher number is more transparent (thus '100' is fully invisible)\n     */\n    @block({\n      type: \"command\",\n      text: (transparency) => `Set video to ${transparency}% transparent`,\n      arg: \"number\"\n    })\n    setVideoTransparencyBlock(transparency: number) {\n      this.setVideoTransparency(transparency);\n    }\n  }\n\n  return ExtensionWithSetVideoTransparencyBlock;\n}\n","import { block } from \"$common/extension/decorators/blocks\";\nimport { withDependencies } from \"../../dependencies\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport video from \"../video\";\n\n/**\n * Mixin a 'toggleVideo' Block to control whether the video feed is on, off, or flipped\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithToggleVideoBlock extends withDependencies(Ctor, video) {\n    /**\n     * A `command` block that sets the current video state\n     * @param state What state to set (\"on\", \"off\", or \"on (flipped)\")\n     * @returns \n     */\n    @block({\n      type: \"command\",\n      text: (state) => `Set video feed to ${state}`,\n      arg: { type: \"string\", options: [\"on\", \"off\", \"on (flipped)\"] }\n    })\n    toggleVideoBlock(state: \"off\" | \"on\" | \"on (flipped)\") {\n      if (state === \"off\") return this.disableVideo();\n      this.enableVideo(state === \"on\");\n    }\n  }\n\n  return ExtensionWithToggleVideoBlock;\n}\n","import { MinimalExtensionConstructor } from \"../../base\";\n\n/**\n * Mixin the ability for an extension to be treated as a cross-platform extension, \n * spanning both the RAISE Playground and App Inventor.\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n    abstract class ExtensionWithAppInventorInterop extends Ctor {\n        get withinAppInventor() {\n            return false; // TODO: Determine what/if there is a way to do this.?\n        }\n    }\n\n    return ExtensionWithAppInventorInterop;\n}\n","import { AbstractConstructor, Environment, ExlcudeFirst, } from \"$common/types\";\nimport { Runtime } from \"$common/types/scratch/vm\";\n\nexport type ExtensionConstructorParams = ConstructorParameters<typeof ConstructableExtension>;\nexport type AuxiliaryExtensionInfoParams = ExlcudeFirst<ExtensionConstructorParams>;\nexport type ExtensionBaseConstructor = AbstractConstructor<ExtensionBase>;\n\nexport abstract class ConstructableExtension {\n  /**\n   * @summary This member function (or 'method') will be called when a user adds your extension via the Extensions Menu (i.e. when your extension is instantiated)\n   * @example\n   * // Initialize class field(s)\n   * private count: number;\n   *\n   * init() {\n   *  count = 0;\n   * }\n   * @example\n   * // Interact with environment's runtime\n   * init(env: Environment) {\n   *  env.runtime.emit(RuntimeEvent.ProjectStart);\n   * }\n   * @example\n   * // Nothing to initialize\n   * init() {}\n   * @description This function is intended to behave exactly like a constructor, used to initialize the state of your extension.\n   *\n   * The reason we use this function INSTEAD of a constructor is so that the base Extension class can manage the construction of this class.\n   * \n   * This also allows us to enable this method to be async (if you'd like).\n   * @param {Environment} env An object that allows your Extension to interact with the Scratch Environment. Currently is a little bare, but will be expanded soon.\n   * Can be ommitted if not needed.\n   *\n   * For Scratch developers: The `runtime` property on env is the same as the runtime passed to non-Typescript-Framework Extension constructors\n   */\n  abstract init(env: Environment): void | Promise<void>;\n\n  protected async internal_init() {\n    const runtime = this.runtime;\n    return await Promise.resolve(this.init({\n      runtime,\n      get extensionManager() { return runtime.getExtensionManager() }\n    }));\n  }\n\n  /**\n   *\n   * @param runtime The 'runtime' connected to the scratch-vm that enables your extension to interact with the scratch workspace\n   * @param name The name of this extension.\n   * @param id The ID of this extension.\n   * @param blockIconURI\n   */\n  constructor(\n    readonly runtime: Runtime,\n    readonly name: string,\n    readonly id: string,\n    readonly blockIconURI: string,\n    readonly blockColor: string,\n    readonly menuColor: string,\n    readonly menuSelectColor: string\n  ) {\n  }\n}\n\nexport const extensionsMap = new Map<string, ExtensionBase>();\n\nexport abstract class ExtensionBase extends ConstructableExtension {\n  constructor(FORBIDDEN: never) {\n    // @ts-ignore\n    super(...arguments);\n    extensionsMap.set(this.id, this);\n  }\n}","import { BaseScratchExtensionConstuctor } from \"..\";\nimport { ArgEntry, VersionArgTransformMechanism, ArgIdentifier } from \"$common/types\";\n\n/**\n * Mixin the ability for extensions to have their blocks 'versioned', \n * so that projects serialized with past versions of blocks can be loaded.\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\n\n\nconst CORE_EXTENSIONS = [\n    'argument',\n    'colour',\n    'control',\n    'data',\n    'event',\n    'looks',\n    'math',\n    'motion',\n    'operator',\n    'procedures',\n    'sensing',\n    'sound'\n];\n\n// Constants referring to 'primitive' blocks that are usually shadows,\n// or in the case of variables and lists, appear quite often in projects\n// math_number\nconst MATH_NUM_PRIMITIVE = 4; // there's no reason these constants can't collide\n// math_positive_number\nconst POSITIVE_NUM_PRIMITIVE = 5; // with the above, but removing duplication for clarity\n// math_whole_number\nconst WHOLE_NUM_PRIMITIVE = 6;\n// math_integer\nconst INTEGER_NUM_PRIMITIVE = 7;\n// math_angle\nconst ANGLE_NUM_PRIMITIVE = 8;\n// colour_picker\nconst COLOR_PICKER_PRIMITIVE = 9;\n// text\nconst TEXT_PRIMITIVE = 10;\n// event_broadcast_menu\nconst BROADCAST_PRIMITIVE = 11;\n// data_variable\nconst VAR_PRIMITIVE = 12;\n// data_listcontents\nconst LIST_PRIMITIVE = 13;\n\n// Map block opcodes to the above primitives and the name of the field we can use\n// to find the value of the field\nconst primitiveOpcodeInfoMap = {\n    math_number: [MATH_NUM_PRIMITIVE, 'NUM'],\n    math_positive_number: [POSITIVE_NUM_PRIMITIVE, 'NUM'],\n    math_whole_number: [WHOLE_NUM_PRIMITIVE, 'NUM'],\n    math_integer: [INTEGER_NUM_PRIMITIVE, 'NUM'],\n    math_angle: [ANGLE_NUM_PRIMITIVE, 'NUM'],\n    colour_picker: [COLOR_PICKER_PRIMITIVE, 'COLOUR'],\n    text: [TEXT_PRIMITIVE, 'TEXT'],\n    event_broadcast_menu: [BROADCAST_PRIMITIVE, 'BROADCAST_OPTION'],\n    data_variable: [VAR_PRIMITIVE, 'VARIABLE'],\n    data_listcontents: [LIST_PRIMITIVE, 'LIST']\n};\n\n\nconst soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' +\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n/**\n * Generate a unique ID, from Blockly.  This should be globally unique.\n * 87 characters ^ 20 length > 128 bits (better than a UUID).\n * @return {string} A globally unique ID string.\n */\nconst uid = function () {\n    const length = 20;\n    const soupLength = soup_.length;\n    const id = [];\n    for (let i = 0; i < length; i++) {\n        id[i] = soup_.charAt(Math.random() * soupLength);\n    }\n    return id.join('');\n};\n\nexport default function (Ctor: BaseScratchExtensionConstuctor) {\n    abstract class ExtensionWithConfigurableSupport extends Ctor {\n        \n        /**\n         * A function that appends the version number to each opcode on project save\n         * \n         * @param {Array} objTargets The obj.targets array from the Scratch project\n         * @return {Array} An updated object.targets array with the new opcodes\n        */\n        alterOpcodes(objTargets: any) {\n            const newTargets  = [];\n            // Loop through the object targets\n            for (const object of objTargets) {\n                for (const blockId in object.blocks) {\n                    const block = object.blocks[blockId];\n                    // Get the opcode from the block\n                    let blockInfoIndex = block.opcode.replace(`${block.opcode.split(\"_\")[0]}_`, \"\");\n                    // Add the version number to the opcode\n                    const versions = this.getVersion(blockInfoIndex);\n                    if (versions && versions.length > 0) {\n                        object.blocks[blockId].opcode = `${object.blocks[blockId].opcode}_v${versions.length}`;\n                    } else {\n                        object.blocks[blockId].opcode = `${object.blocks[blockId].opcode}_v0`;\n                    }\n                }\n                newTargets.push(object);\n            }\n            return newTargets;\n        }\n        \n        /**\n         * A function that modifies a project JSON based on any updated\n         * versioning implementations\n         * \n         * @param {object} projectJSON The project JSON to be modified\n         * @return {object} An updated project JSON compatible with the current version of the extension\n        */\n        alterJSON(projectJSON: any) {\n            // Collect the targets\n            const targetObjects = projectJSON.targets\n            .map((t, i) => Object.assign(t, { targetPaneOrder: i }))\n            .sort((a, b) => a.layerOrder - b.layerOrder);\n\n            const newTargets = [];\n            for (const object of targetObjects) {\n                const newBlocks = {};\n                for (const blockId in object.blocks) {\n                    let blockJSON = object.blocks[blockId];\n                    let version = 0;\n                    const blockOpcode = blockJSON.opcode;\n\n                    // Check if version name is included\n                    const regex = /_v(\\d+)/g;\n                    const matches = blockOpcode.match(regex); // Get all matches\n\n                    // Collect the version number\n                    if (matches) {\n                        const lastMatch = matches[matches.length - 1]; \n                        const versionMatch = lastMatch.match(/_v(\\d+)/); \n\n                        if (versionMatch) {\n                            version = parseInt(versionMatch[1], 10); // Extract and parse the version number\n                        }\n                        blockJSON.opcode = blockOpcode.replace(regex, \"\"); // Remove all version numbers from the opcode\n                    }\n\n                    const extensionID = this.getExtensionIdForOpcode(blockJSON.opcode);\n                    const blocksInfo = this.getInfo().blocks.reduce((acc, tempBlock: any) => {\n                        acc[tempBlock.opcode] = tempBlock;\n                        return acc;\n                    }, {});\n\n                    const block = object.blocks[blockId];\n                    // If the block is under the current extension\n                    if (extensionID == this.getInfo().id && !block.opcode.includes(\"_menu_\")) {\n                        let blockInfoIndex = block.opcode.replace(`${block.opcode.split(\"_\")[0]}_`, \"\");\n                        let oldIndex = blockInfoIndex;\n                        const nameMap = this.createNameMap(blocksInfo);\n                        if (nameMap[version] && nameMap[version][blockInfoIndex]) {\n                            blockInfoIndex = nameMap[version][blockInfoIndex];\n                        }\n                        // Update the opcode to be the current version name\n                        block.opcode = block.opcode.replace(oldIndex, blockInfoIndex);\n                        const versions = this.getVersion(blockInfoIndex);\n\n                        let originalType = blocksInfo[blockInfoIndex].blockType;\n                        let first = true;\n\n                        // If we need to update the JSON to be compatible with the current version\n                        if (versions && version < versions.length) {\n                            // Remove the image entries from the arguments\n                            const blockArgs = this.removeImageEntries(blocksInfo[blockInfoIndex].arguments);\n                            // Gather values\n                            let { inputs, variables } = this.gatherInputs(block);\n                            let fields = this.gatherFields(block, blockArgs);\n                            let totalList = inputs.concat(fields);\n                            const newInputs = {};\n                            const newFields = {};\n                            let changed = false;\n                            let moveToSay = false;\n\n                            // Apply each version modification as needed\n                            \n                            for (let i = version; i < versions.length; i++) {\n                                if (versions[i].transform) {\n                                    // Create the map to be used in the mechanism from ArgEntry objects\n                                    const map = new Map();\n                                    for (let i = 0; i < totalList.length; i++) {\n                                        map.set(totalList[i].id, totalList[i]);\n                                    }\n                                    const mechanism: VersionArgTransformMechanism = {\n                                        arg: (identifier: ArgIdentifier) => map.get(identifier),\n                                        args: () => Array.from(map.values()),\n                                    }\n                                    // Complete the transformation\n                                    const entries: ArgEntry[] = versions[i].transform(mechanism);\n                                    // Update the ArgEntry objects' IDs and get position mappings\n                                    const { newEntries, mappings } = this.updateEntries(entries);\n                                    totalList = newEntries;\n                                    // Update variable positions\n                                    variables = this.updateDictionary(variables, mappings)\n                                }\n                                if (versions[i].previousType) { \n                                    if (first) {\n                                        originalType = versions[i].previousType;\n                                        first = false;\n                                    }\n                                }\n                            }\n\n                            // Re-create the project JSON inputs/fields with the new values\n                            for (let i = 0; i < Object.keys(blockArgs).length; i++) {\n                                const argIndex = Object.keys(blockArgs)[i];\n                                // If there's a variable in the argIndex position\n                                if (Object.keys(variables).includes(argIndex)) {\n                                    newInputs[argIndex] = variables[argIndex];\n                                } \n                                // If we need to place the value in a field\n                                else if (blockArgs[argIndex].menu) {\n                                    let fieldValue = totalList[argIndex];\n                                    if (typeof fieldValue == \"number\") {\n                                        fieldValue = String(fieldValue);  \n                                    }\n                                    newFields[argIndex] = {\n                                        name: String(argIndex),\n                                        value: fieldValue,\n                                        id: null\n                                    }\n                                } \n                                // If we need to place the value in an input\n                                else {\n                                    const typeNum = this.getType(blockArgs[argIndex].type);\n                                    newInputs[argIndex] = [\n                                        1, [\n                                            typeNum,\n                                            String(totalList[argIndex].value)\n                                        ]\n                                    ]\n                                }\n                            }\n            \n                            // Re-assign fields and inputs\n                            block.inputs = newInputs;\n                            block.fields = newFields;\n            \n                            // If we need to move the information to a 'say' block, since \n                            // we need to keep it connected to the previous/next blocks\n                            if (originalType != blocksInfo[blockInfoIndex].blockType) {\n                                if ((originalType == \"command\" || originalType == \"hat\") && blocksInfo[blockInfoIndex].blockType == \"reporter\") { // square to circle\n                                    const oldID = blockId;\n                                    const next = block.next;\n                                    // Re-assign the ID of the current block\n                                    block.id = uid();\n                                    // Create the new block\n                                    const newBlock = Object.create(null);\n                                    newBlock.id = oldID;\n                                    newBlock.parent = block.parent;\n                                    block.parent = newBlock.id;\n                                    newBlock.fields = {};\n                                    // Input should be the reporter block variable\n                                    newBlock.inputs = {\n                                        MESSAGE: [\n                                            3, \n                                            block.id,\n                                            [\n                                                10, \n                                                \"Hello\"\n                                            ]\n                                        ]\n                                    }\n                                    newBlock.next = next;\n                                    block.next = null;\n                                    newBlock.opcode = \"looks_say\";\n                                    newBlock.shadow = false;\n                                    \n                                    // Since we changed the block ID, we need to update the \n                                    // block's input blocks to match\n                                    for (const key of Object.keys(block.inputs)) {\n                                        if (block.inputs[key].block) {\n                                            let inputBlock = block.inputs[key].block;\n                                            if (object.blocks[inputBlock]) {\n                                                object.blocks[inputBlock].parent = block.id;\n                                                block.inputs[key].shadow = block.inputs[key].block;\n                                            }\n                \n                                        }\n                                    }\n                                    // Set the blocks in the JSON\n                                    newBlocks[block.id] = block;\n                                    newBlocks[newBlock.id] = newBlock;\n                                } \n                                // If we need to create a command from a reporter\n                                else if (originalType == \"reporter\" && (blocksInfo[blockInfoIndex].blockType == \"command\" || blocksInfo[blockInfoIndex].blockType == \"button\" || blocksInfo[blockInfoIndex].blockType == \"hat\")) { // reporter to command) { // circle to square\n                                    // If the previous reporter block has a parent\n                                    if (object.blocks[block.parent]) {\n                                        const parentBlock = object.blocks[block.parent];\n                                        // Remove the reporter variable from the parent block's inputs\n                                        for (let key of Object.keys(parentBlock.inputs)) {\n                                            let values = [];\n                                            let index = 0;\n                                            for (const value of parentBlock.inputs[key]) {\n                                                if (value != blockId) {\n                                                    if (index == 0) {\n                                                        // We'll also need to set the shadow to 1\n                                                        // since we removed the variable\n                                                        values.push(1);\n                                                    } else {\n                                                        values.push(value);\n                                                    }\n                                                }\n                                                index = index + 1;\n                                            }\n                                            parentBlock.inputs[key] = values; \n                                        }\n                                        // Update the current block to be a command block\n                                        if (blocksInfo[blockInfoIndex].blockType == \"command\") {\n                                            block.parent = null;\n                                            block.topLevel = true;\n                                        }\n                                        \n                                    } \n                                } else if ((originalType == \"command\") && (blocksInfo[blockInfoIndex].blockType == \"hat\")) {\n                                    if (object.blocks[block.parent]) {\n                                        const oldId = block.parent;\n                                        const parentBlock = object.blocks[block.parent];\n                                        parentBlock.next = null;\n                                        block.parent = null;\n                                        block.topLevel = true;\n                                        newBlocks[blockId] = block;\n                                        newBlocks[oldId] = parentBlock;\n                                    }\n                                }\n                            }\n                        }\n                        \n                    } \n                    // Set the blocks dictionary\n                    if (!Object.keys(newBlocks).includes(blockId)) {\n                        newBlocks[blockId] = block;\n                    }\n                }\n                // Update the target with the new blocks\n                object.blocks = newBlocks;\n                newTargets.push(object);\n            }\n            // Update the project JSON with the new target\n            projectJSON.targets = newTargets;\n            return projectJSON;\n        }\n\n        /**\n         * Helper function to get the extension ID from a block's opcode\n         * \n         * @param {string} opcode The block's opcode\n         * @return {string} The extension ID\n        */\n        getExtensionIdForOpcode(opcode: string): string {\n            // Allowed ID characters are those matching the regular expression [\\w-]: A-Z, a-z, 0-9, and hyphen (\"-\").\n            const index = opcode.indexOf('_');\n            const forbiddenSymbols = /[^\\w-]/g;\n            const prefix = opcode.substring(0, index).replace(forbiddenSymbols, '-');\n            if (CORE_EXTENSIONS.indexOf(prefix) === -1) {\n                if (prefix !== '') return prefix;\n            }\n        };\n\n        /**\n         * Helper function used to create a position mapping from one version to another as well as\n         * assign each ArgEntry object a new ID\n         * \n         * @param {ArgEntry[]} entries The updated entries to create the mapping from\n         * @return {ArgEntry[]} returns.newEntries - The ArgEntry objects with updated IDs\n         * @return {object} returns.mappings - A dictionary with the position mappings\n        */\n        updateEntries(entries: ArgEntry[]) {\n            const mappings = {};\n            let newEntries = [];\n            // Loop through the arg entries\n            for (let i = 0; i < entries.length; i++) {\n                // If the value hasn't just been added\n                if (entries[i].id) {\n                    // Set the positional dictionary\n                    mappings[entries[i].id] = String(i);\n                }   \n                // Update the new ArgEntry array with the new ID\n                newEntries.push({id: String(i), value: entries[i].value});\n            }\n            return { newEntries, mappings };\n\n        }\n\n        /**\n         * This function creates a dictionary with the opcode associated with each block\n         * at each version, so that if an opcode changes during a version, we'll be able\n         * to find the correct block.\n         * \n         * @param {object} blockInfo A dictionary with the information of each block from the extension\n         * @return {object} The dictionary with each block's opcode at each version\n        */\n        createNameMap(blocksInfo: any) {\n            const versionMap = new Map();\n            // Loop through every block in the extension\n            for (const opcode of Object.keys(blocksInfo)) {\n                // Get version information for each extension\n                const versions = this.getVersion(opcode);\n                // If there is version information\n                if (versions && versions.length > 0) {\n                    let tempName = opcode;\n                    // Loop through the versions from most current to least current\n                    for (let index = versions.length - 1; index >= 0; index--) { \n                        if (!versionMap.has(index)) {\n                            versionMap[index] = {};\n                        }\n                        // Collect the name for the version, if it's not the current opcode\n                        const version = versions[index];\n                        if (typeof version == \"object\" && version.previousName) { // check if the version entry has a name\n                            const oldName = version.previousName;\n                            tempName = oldName;\n                        }\n                        // Set the map entry for the version and the name at that version\n                        if (tempName != opcode) {\n                            versionMap[index][tempName] = opcode;\n                        }\n                    }\n                }\n            }\n            return versionMap;\n        }\n\n\n        /**\n         * Remove image entries from the passed-in arguments for each block from the extension\n         * \n         * @param {object} dict The arguments of the block\n         * @return {object} The arguments of the block with the static images removed\n         */\n        removeImageEntries(dict: any) {\n            const filteredDict = {};\n            for (const [key, value] of Object.entries(dict)) {\n                if ((value as any).type !== 'image') {\n                    filteredDict[key] = value;\n                }\n            }\n            return filteredDict;\n        }\n\n        /**\n         * Gather the values from the 'inputs' property of a block as well as the block's variables\n         * \n         * @param {object} blockJSON The block to gather the inputs from\n         * @return {ArgEntry[]} return.inputs - An array of ArgEntry objects with each value representing an input\n         * @return {object} return.variables - A dictionary with all the block's variables as values and their positions as keys\n         */\n        gatherInputs(blockJSON: any): any {\n            const variables = {};\n            const args: ArgEntry[] = [];\n            // Loop through the block's inputs\n            if (blockJSON.inputs && Object.keys(blockJSON.inputs).length > 0) {\n                Object.keys(blockJSON.inputs).forEach(input => {\n                    const keyIndex = input;\n                    input = blockJSON.inputs[input];\n                    // If there is a variable in the input\n                    if (typeof input[1] == \"string\") {\n                        // Set the variables dictionary accordingly\n                        variables[keyIndex] = [\n                            3,\n                            input[1],\n                            input[2]\n                        ]\n                        args.push({id: keyIndex, value: input[2][1]});\n                    } else {\n                        // If the input is a value, push that value according to type\n                        const type = parseFloat(input[1][0]);\n                        switch (type) {\n                            case 6: // WHOLE_NUM_PRIMITIVE\n                            case 5: // POSITIVE_NUM_PRIMITIVE\n                            case 7: // INTEGER_NUM_PRIMITIVE\n                            case 8: // ANGLE_NUM_PRIMITIVE\n                            case 9: // COLOR_PICKER_PRIMITIVE\n                            case 4: // MATH_NUM_PRIMITIVE\n                            {\n                                args.push({id: keyIndex, value: parseFloat(input[1][1])});\n                                break;\n                            }\n                            case 10: // TEXT_PRIMITIVE\n                            default: // BROADCAST_PRIMITIVE, VAR_PRIMITIVE, LIST_PRIMITIVE\n                            {\n                                args.push({id: keyIndex, value: input[1][1]})\n                                break;\n                            }\n                        }\n                    }\n                })\n            }\n            return { inputs: args, variables: variables };\n        }\n\n        /**\n         * Gather the values from the 'fields' property of a block\n         * \n         * @param {object} blockJSON The block to gather the inputs from\n         * @return {ArgEntry[]} An array of ArgEntry objects representing each field\n         */\n        gatherFields(blockJSON: any, argList: any) {\n            const args: ArgEntry[] = [];\n            // Loop through each field\n            if (blockJSON.fields && Object.keys(blockJSON.fields).length > 0) {\n                Object.keys(blockJSON.fields).forEach(field => {\n                        const keyIndex = field;\n                        field = blockJSON.fields[field];\n                        // Collect the field's value\n                        let value = (field as any).value;\n                        let argType = argList[(field as any).name].type;\n                        // Convert the value to its correct type\n                        if (argType == \"number\" || argType == \"angle\") {\n                            value = parseFloat(value);\n                        }\n                        args.push({id: keyIndex, value: value})\n                })\n            }\n            return args;\n        }\n\n        /**\n         * If the positions of the arguments change between version transformations, we\n         * use this function to update the variables dictionary to contain each variable's\n         * new position\n         * \n         * @param {object} originalDict The dictionary with the old variable positions\n         * @param {object} keyMapping The position transformations corresponding to a version transformation\n         * @return {object} A dictionary with the new variable positions\n        */\n        updateDictionary(originalDict: any, keyMapping: any) {\n            const updatedDict = {};\n            for (const [oldKey, newKey] of Object.entries(keyMapping)) {\n                // If the old variable exists at that position...\n                if (originalDict.hasOwnProperty(oldKey)) {\n                    const newEntry = originalDict[oldKey];\n                    // ... update the new dictionary at the new position\n                    updatedDict[newKey as any] = newEntry;\n                }\n            }\n            return updatedDict;\n        }\n\n        /**\n         * Taking a type as provided by the argument info from the extension and converting it \n         * to an integer (as would be represented in the JSON)\n         * \n         * @param {string} type The type of the value\n         * @return {number} The enum value of the type\n        */\n        getType(type: string): number {\n            let opcode: string;\n            // Collect the opcode for each type\n            switch (type) {\n                case \"number\": {\n                    opcode = 'math_number';\n                    break;\n                }\n                case \"angle\": {\n                    opcode = 'math_angle';\n                    break;\n                }\n                case \"color\": {\n                    opcode = 'colour_picker';\n                    break;\n                }\n                case \"string\":\n                default:\n                {\n                    opcode = 'text';\n                    break;\n                }\n            }\n            // Map the opcode to its enum type\n            return primitiveOpcodeInfoMap[opcode][0];\n        }\n\n        /**\n         * If a block changes from a reporter to a command, we use this function\n         * to remove the reporter version from its parent in the JSON\n         * \n         * @param {object} block The parent block we'll use to remove the input\n         * @param {object} removeBlock The block to remove\n         * @param {object} argInfo The type info for the block's arguments so we can \n         * correctly set the default value\n         * @return {number} The parent block with the input removed\n        */\n        removeInput(block: any, removeBlock: any, argInfo: any) {\n            const inputs = block.inputs;\n            const newInputs = {};\n            // Loop through block inputs\n            for (const key of Object.keys(inputs)) {\n                // If the input contains the block we need to remove\n                if (inputs[key] && inputs[key].includes(removeBlock.id)) {\n                    // Get the default value for the current input position\n                    const typeNum = this.getType(argInfo[key].type);\n                    let defaultVal = argInfo[key].defaultValue;\n                    if (String(defaultVal) == \"undefined\") {\n                        switch(argInfo[key].type) {\n                            case \"number\": \n                            case \"angle\": \n                            case \"color\": {\n                                defaultVal = 0;\n                                break;\n                            }\n                            case \"string\": {\n                                defaultVal = \"string\";\n                                break;\n                            }\n                        }\n                    }\n                    // Set the input value to be the default instead of the variable\n                    newInputs[key] = [\n                        1, [\n                            typeNum,\n                            defaultVal\n                        ]\n                    ]\n                // Otherwise, leave the input as is\n                } else {\n                    newInputs[key] = inputs[key];\n                }\n            }\n            block.inputs = newInputs;\n            return block;\n        }\n    }\n\n    return ExtensionWithConfigurableSupport;\n}","import { ExtensionInstanceWithFunctionality, MixinName, optionalMixins } from \"..\";\nimport { ExtensionBaseConstructor } from \"../../ExtensionBase\";\n\n/**\n * Mixin the ability for extensions to check which optional mixins they support\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function (Ctor: ExtensionBaseConstructor, supported: string[]) {\n  abstract class ExtensionWithConfigurableSupport extends Ctor {\n\n    supports<const TKey extends MixinName>(mixinName: TKey): this is typeof this & ExtensionInstanceWithFunctionality<[TKey]> {\n      return supported.includes(mixinName);\n    }\n  }\n\n  return ExtensionWithConfigurableSupport;\n}","import { ExtensionWithFunctionality, MixinName, optionalMixins } from \"./mixins/index\";\nimport { ExtensionBase } from \"./ExtensionBase\";\nimport scratchInfo from \"./mixins/base/scratchInfo\";\nimport scratchVersions from \"./mixins/base/scratchVersioning\";\nimport supported from \"./mixins/base/supported\";\nimport { ExtensionMenuDisplayDetails, Writeable } from \"$common/types\";\nimport { tryCaptureDependencies } from \"./mixins/dependencies\";\nimport { tryCreateBundleTimeEvent } from \"$common/utils\";\n\nexport const extensionBundleEvent = tryCreateBundleTimeEvent<{ details: ExtensionMenuDisplayDetails, addOns: MixinName[] }>(\"extension\");\n\n/**\n * Creates the base class that your Extension should 'extend' which is compatible with your request. \n * \n * Your request will have the following two parts:\n * @param details The details about how your extension should display and behave within the Extensions Menu.\n * Only the `name` field is required, but before your extension can be officially published, \n * it will additionally need a `description`, `iconURL`, and `insetIconURL`\n * @param addOns An optional collection of specifiers about what functionality this extension should have.\n * In this way, the functionality your Extension has access to (through its base class) is configurable.\n * \n * To see what `addOns` you can specify, place your cursor after the details parameter and type a double quote (\"). \n * Your IDE (code editor) should then suggest what values you can provide (e.g. `\"ui\"`, `\"customArguments\"`, `\"customSaveData\"`, etc.). \n * \n * **Note:** The order of the `addOns` does not matter.\n * @returns \n * @example Defining an extension with a name and description (and no add ons)\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\", description: \"Some description...\" }) {\n *  ...\n * }\n * ```\n * @example Defining an extension with a name and UI functionality\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\" }, \"ui\") {\n *  ...\n * }\n * ```\n * @example Defining an extension with a name and UI & custom arguments functionality\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\" }, \"ui\", \"customArguments\") {\n *  ...\n * }\n * ```\n */\nexport const extension = <const TSupported extends readonly MixinName[]>(\n  details: ExtensionMenuDisplayDetails,\n  ...addOns: Writeable<TSupported>\n): ExtensionWithFunctionality<[...TSupported]> & typeof ExtensionBase => {\n\n  if (details) extensionBundleEvent?.fire({ details, addOns });\n\n  const Base = scratchVersions(scratchInfo(supported(ExtensionBase, addOns))) as ExtensionWithFunctionality<[...TSupported]>;\n\n  if (!addOns) return Base;\n\n  const { Result, allSupported } = recursivelyApplyMixinsAndDependencies(Base, addOns);\n  return supported(Result, Array.from(allSupported)) as typeof Result;\n}\n\nconst recursivelyApplyMixinsAndDependencies = <const TSupported extends readonly MixinName[]>(\n  Base: ExtensionWithFunctionality<[...TSupported]>,\n  addons: TSupported,\n  alreadyAdded: Set<MixinName> = new Set()\n): { Result: ExtensionWithFunctionality<[...TSupported]>, allSupported: Set<MixinName> } => {\n  const Result = addons\n    .filter(addon => !alreadyAdded.has(addon))\n    .map(key => {\n      alreadyAdded.add(key);\n      return key;\n    })\n    .map(key => optionalMixins[key])\n    .reduce((acc, mixin) => {\n      const { dependencies, MixedIn } = tryCaptureDependencies(() => mixin(acc));\n      return !dependencies\n        ? MixedIn\n        : recursivelyApplyMixinsAndDependencies(MixedIn, dependencies, alreadyAdded).Result as typeof MixedIn;\n    }, Base);\n\n  return { Result, allSupported: alreadyAdded }\n}\n\nexport type ExtensionConstructor<TSupported extends MixinName[] = []> = ReturnType<typeof extension<TSupported>>;\nexport type ExtensionInstance<TSupported extends MixinName[] = []> = InstanceType<ExtensionConstructor<TSupported>>;","import { ExtensionMenuDisplayDetails, ExtensionBlocks, BlockDefinitions, Translations, OneArgBlock, MultipleArgsBlock, NoArgsBlock } from \"$common/types\";\nimport { isFunction } from \"$common/utils\";\nimport { extension } from \"./index\";\nimport { getImplementationName } from \"./mixins/base/scratchInfo/index\";\n\n/**\n * @summary Base class for extensions implemented via the Typescript Extension Framework (using the \"generic\" strategy).\n * @example\n * class MyExtension extends Extension<\n *  { // Display details\n *    name: \"My Extension\",\n *    description: \"This is my extension\",\n *    iconURL: \"example.png\",\n *    insetIconURL: \"example.svg\"\n *  },\n *  { // Blocks\n *    myBlock: (someArg: number) => void;\n *  }\n * > {\n *  init(env: Environment): { ... };\n *  defineBlocks(): MyExtension[\"BlockDefinitions\"] { return ... }\n * }\n * @description Extension developers will create Typescript classes that `extend` (or 'inherit', or 'implement') this `Extension` class.\n *\n * In order to `extend` this class, you must first specify 2 generic type arguments, which effectively describe what kind of Extension you're implementing.\n *\n * More specifically, the 2 generic type arguments describe how this extension is presented to the user (by specifyng the details displayed in the Extensions Menu),\n * and what this Extension actually does (by specifying the blocks it will define).\n *\n * By declaring that we're extending an `Extension` with our specific generic type arguments,\n * Typescript holds us accountable to implement exactly what we said we would (all in order to make a working extension).\n *\n * This includes:\n * * Defining an `init` method, which is used INSTEAD of a constructor\n * * Defining a `defineBlocks` method that does just that: defines this extension's blocks\n * @template MenuDetails How the extension should display in the extensions menu\n * @template Blocks What kind of blocks this extension implements\n * @link https://www.typescriptlang.org/docs/handbook/2/generics.html Learn more about generics!\n */\n\nexport abstract class Extension<\n  MenuDetails extends ExtensionMenuDisplayDetails,\n  Blocks extends ExtensionBlocks\n> extends extension(undefined, \"ui\", \"customSaveData\", \"customArguments\") {\n\n  readonly BlockFunctions: Blocks;\n  readonly BlockDefinitions: BlockDefinitions<typeof this>;\n  readonly Translations: Translations<typeof this>;\n\n  /**\n   * @summary Extension member method that returns an object defining all blocks that belong to the extension.\n   * @description Every block your extension implements (defined by the second generic argument of the Extension class), will have an entry in the object return by this function.\n   * Each entry will either be an object or a function that returns an object that provides the:\n   * - type: the type of block\n   * - text: what is displayed on the block\n   * - arg or args: the arguments the block accepts\n   * - operation: the function that is called when the blocked is executed\n   * @example\n   * // Returning an object with two block definition function for 'someBlock'\n   * defineBlocks(): ExampleExtension[\"BlockDefinitions\"] {\n   *  return {\n   *    // Using object syntax\n   *    someBlock: {\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    },\n   *    // Using arrow function syntax\n   *    someBlock: (self: MyExtension) => ({\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    }),\n   *    // Using method function syntax\n   *    someOtherBlock(self: MyExtension) {\n   *      const type = BlockType.Reporter;\n   *      const arg = ArgumentType.String;\n   *      return {\n   *        arg, type,\n   *        text: (argument) => `Some text about ${argument}`,\n   *        operation: (argument) => {\n   *          // do something\n   *        }\n   *      }\n   *    }\n   *  }\n   * }\n   * @see BlockDefinitions\n   * @returns {BlockDefinitions<Blocks>} An object defining 'block definition' objects / functions for each block associated with this Extension.\n   */\n  abstract defineBlocks(): BlockDefinitions<Extension<MenuDetails, Blocks>>;\n\n  protected override async internal_init() {\n    await super.internal_init();\n    const blocks = this.defineBlocks();\n    const self = this;\n    for (const opcode in blocks) {\n      this.validateOpcode(opcode);\n      const block = blocks[opcode];\n      const { operation, text, arg, args, type } = isFunction(block) ? block.call(this, this) : block;;\n      this.pushBlock(opcode,\n        (arg\n          ? { text, type, arg } satisfies OneArgBlock\n          : args\n            ? { text, type, args } satisfies MultipleArgsBlock\n            : { text, type } satisfies NoArgsBlock\n        ) as any,\n        operation);\n      const internalFuncName = getImplementationName(opcode);\n      (this as unknown)[opcode] = function () { return self[internalFuncName].call(self, ...arguments); };\n    }\n  }\n\n  private validateOpcode(opcode: string) {\n    if (!(opcode in this)) return;\n\n    const error = `The Extension has a member defined as '${opcode}', ` +\n      `but that name should be reserved for the opcode of the block with the same name. ` +\n      `Please rename your member, and attach the \"validateGenericExtension\" decorator to your class ` +\n      `so that this can be an error in your IDE and not at runtime.`;\n\n    throw new Error(error);\n  }\n}\n","import { BlockMetadata, Argument, ReturnTypeByBlockType, ScratchBlockType, NoArgsBlock, OneArgBlock, BlockUtilityWithID, InlineImage, InlineImageSpecifier } from \"$common/types\";\nimport { block } from \"$common/extension/decorators/blocks\";\nimport { ExtensionInstance } from \"..\";\nimport { TypedMethodDecorator } from \".\";\n\nconst process = (type: ScratchBlockType, strings: TemplateStringsArray, ...args: any[]) => {\n    if (args.length === 0) return { type, text: strings[0], } satisfies NoArgsBlock;\n    const text = (...placeholders: any[]) => strings.map((str, i) => `${str}${placeholders[i] ?? \"\"}`).join(\"\");\n    if (args.length === 1) return { type, text, arg: args[0] } satisfies OneArgBlock;\n    return { type, text, args };\n}\n\nexport function makeDecorator<T extends ScratchBlockType>(type: T): TemplateEngine<T>[\"execute\"] {\n    type AnyBlockMetadata = BlockMetadata<(...args: any[]) => any>;\n\n    type FirstArgumentAsFunction = (instance: ExtensionInstance, tag: Utility.TaggedTemplate<any[], AnyBlockMetadata>) => AnyBlockMetadata;\n    type FirstArgumentAsTemplateStrings = TemplateStringsArray;\n    type FirstArgument = FirstArgumentAsFunction | FirstArgumentAsTemplateStrings;\n\n    return function decoratorFn(builderOrStrings: FirstArgument, ...args) {\n        return function (target, context) {\n\n            type BlockMetadataFunction = (instance: ExtensionInstance) => AnyBlockMetadata\n\n            const input = typeof builderOrStrings == \"function\"\n                ? ((instance: ExtensionInstance) => builderOrStrings.call(instance, instance, process.bind(null, type))) satisfies BlockMetadataFunction\n                : process(type, builderOrStrings, ...args) as AnyBlockMetadata;\n\n            return block(input)(target, context);\n        }\n    }\n}\n\nnamespace Utility {\n    export type TaggedTemplate<Args extends any[], Return> = (strings: TemplateStringsArray, ...args: Args) => Return;\n    export type OptionalPromise<T> = T | Promise<T>;\n}\n\n\nnamespace Argument {\n    type TRemoveUtil<T extends any[]> = T extends [...infer R extends any[], BlockUtilityWithID] ? R : T;\n    export type MapToScratch<T extends any[], Internal extends TRemoveUtil<T> = TRemoveUtil<T>> = {\n        [k in keyof Internal]:\n        Internal[k] extends BlockUtilityWithID ? never :\n        Internal[k] extends InlineImageSpecifier ? InlineImage :\n        Argument<Internal[k]>\n    }\n}\n\n// TODO: Restrict return based on Scratch type\ninterface TemplateEngine<TBlockType extends ScratchBlockType> {\n    /**\n     * \n     */\n    execute<\n        This extends ExtensionInstance,\n        Args extends any[],\n        Return extends Utility.OptionalPromise<ReturnTypeByBlockType<TBlockType>>\n    >\n        (\n            strings: TemplateStringsArray, ...args: Argument.MapToScratch<Args>\n        ): TypedMethodDecorator<This, Args, Return, ((...args: Args) => Return)>;\n\n    /**\n     * \n     */\n    execute<\n        This extends ExtensionInstance,\n        Args extends any[],\n        Return extends Utility.OptionalPromise<ReturnTypeByBlockType<TBlockType>>,\n    >\n        (\n            builder: (\n                this: This,\n                instance: This,\n                tag: Utility.TaggedTemplate<Argument.MapToScratch<Args>, BlockMetadata<(...args: Args) => Return>>,\n            ) => BlockMetadata<(...args: Args) => Return>\n        ): TypedMethodDecorator<This, Args, Return, ((...args: Args) => Return)>;\n}\n\n\nexport const scratch = {\n    reporter: makeDecorator(\"reporter\"),\n    command: makeDecorator(\"command\"),\n    hat: makeDecorator(\"hat\"),\n    button: makeDecorator(\"button\"),\n}","import { ExtensionBlocks, ExtensionMenuDisplayDetails } from \"$common/types\";\nimport { TypedClassDecorator } from \".\";\nimport { ExtensionConstructor } from \"..\";\nimport { Extension } from \"../GenericExtension\";\n\n/**\n * Used to validate (through type assertion) that a Generic Extension does not\n * define any members with the same name as one of its blocks. \n * \n * The Generic Extension `Extension` class predates this requirment of having no overlap between the keys of blocks and the members of the associated Extension \n * class, so this decorator is provided as an easy way to check and confirm a Generic Extension class is compliant.\n * \n * Runtime errors will also be produced if this condition is not met.\n * @param failure If this extension is not valid, this will be a type that displays the member names causing trouble. \n * @returns \n */\nexport const validGenericExtension = <const T extends Extension<ExtensionMenuDisplayDetails, ExtensionBlocks>>\n  (...failure: T extends Extension<any, infer Blocks> ? T extends { [k in keyof Blocks]?: any } ? [{ [k in keyof Blocks & keyof T]: \"Your class cannot have a member with this name, as it's a name of one of your blocks.\" }] : [] : never):\n  TypedClassDecorator<T, ConstructorParameters<ExtensionConstructor>> => {\n  return function (value, context) { }\n}"],"names":["ExtensionFramework","exports","BlockType","Boolean","Button","Command","Conditional","Event","Hat","Loop","Reporter","ArgumentType","Angle","Color","Number","String","Matrix","Note","Image","Custom","StageLayering","BackgroundLayer","VideoLayer","PenLayer","SpriteLayer","LayerGroups","Language","Azeri","Bahasa_Indonesia","Cymraeg","Dansk","Deutsch","Eesti","English","Euskara","Gaeilge","Galego","Hrvatski","isiZulu","Italiano","Kiswahili","Magyar","Nederlands","Norsk_Nynorsk","Polski","Rapa_Nui","Suomi","Svenska","LanguageKeys","Object","keys","__rest","s","e","t","p","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__esDecorate","ctor","descriptorIn","decorators","contextIn","initializers","extraInitializers","accept","f","TypeError","_","kind","key","target","descriptor","getOwnPropertyDescriptor","name","done","context","access","addInitializer","push","result","get","set","init","unshift","defineProperty","__runInitializers","thisArg","value","useValue","arguments","__awaiter","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","then","apply","SuppressedError","untilTimePassed","timeMs","timeout","setTimeout","clearTimeout","untilObject","getter_1","getter","delay","isString","query","isFunction","toString","Function","isPrimitive","identity","x","untilExternalScriptLoaded","url","scriptLoaded","script","document","createElement","onload","onerror","async","src","body","appendChild","typesafeCall","fn","_this","args","container","assertSameLength","collections","size","reduce","add","Set","Error","decimalToRgb","decimal","a","r","g","b","hexToRgb","hex","replace","m","exec","parseInt","tryCreateBundleTimeEvent","identifier","window","_a","global","registerCallback","callback","id","Symbol","fire","details","callbackIDs","_b","uuidv4","c","Math","random","openUIEvent","registerButtonCallbackEvent","guiDropdownInterop","runtimeKey","runtimeProperties","stateKey","entryKey","updateMethodKey","state","open","update","close","blockIDKey","openUI","runtime","emit","registerButtonCallback","buttonID","on","CssVar","constructor","root","this","parts","join","primary","secondary","tertiary","transparent","light","ui","text","motion","red","sound","control","data","pen","error","extensions","drop","color","modalOverlay","white","whiteDim","whiteTransparent","blackTransparent","primaryTransparent","lightTansparent","highlight","validRegEx","RegExp","invalidRegEx","guards","split","reverse","guardsRegEx","replaceAll","current","desired","saveDataKey","mixin","Ctor","saveDataHandler","undefined","save","toSave","extensionIDs","argumentManager","supports","customArgumentManager","saveData","hooks","onSave","saveTo","load","saved","onLoad","loadFrom","castToType","argumentType","parseFloat","JSON","parse","toMatrix","substring","toFlag","matrixString","Array","fill","map","matrix","flag","index","row","floor","entries","serialize","entry","stringify","CustomArgumentManager","valueLookup","Map","idLookup","setCurrent","setEntry","insert","serializedEntry","serialized","cached","GetIdentifier","request","getCurrent","getEntry","requiresSave","obj","from","filter","SaveKey","forEach","purgeStaleIDs","IsIdentifier","startsWith","IdentifierPrefix","MockBitmapAdapter","makeImage","makeCanvas","resize","image","newWidth","newHeight","stretchWidthCanvas","width","height","getContext","imageSmoothingEnabled","drawImage","stretchHeightCanvas","convertResolution1Bitmap","dataURI","toDataURL","getResizedWidthHeight","oldWidth","oldHeight","STAGE_WIDTH","STAGE_HEIGHT","imageRatio","importBitmap","newSize","convertDataURIToBinary","resizedDataURI","BASE64_MARKER","base64Index","base64","raw","atob","rawLength","array","Uint8Array","ArrayBuffer","charCodeAt","bitmapAdapter","urlHelper","isRenderedTarget","notRenderedTargetError","dependencyListeners","withDependencies","dependencies","pop","mixinsMap","renderToDropdown","Compononent","props","className","elements","getElementsByClassName","findUniqueElementByClass","anchor","children","style","display","menuProbe","isSimpleStatic","menu","isArray","isSimpleDynamic","isStaticWithReporters","isDynamicWithReporters","getMenuName","convertMenuItemsToString","item","assign","asStaticMenu","items","acceptReporters","setMenu","options","menus","alreadyAddedIndex","menuIndex","addOptionsAndGetMenuName","format","description","extractHandlers","element","type","hasHandler","handler","getArgName","getArgumentType","arg","extractArgs","block","argsKey","setDefaultValue","opcode","defaultValue","getDefaultValue","isInlineImage","convertToDisplayText","isDynamicText","textFunc","argPlaceholders","getImplementationName","inlineImageAccessError","checkForBlockContext","blockUtility","isBlockUtilityWithID","console","wrapOperation","operation","argsFromScratch","castedArguments","param","scratchInfo","blockMap","versionMap","pushBlock","definition","has","pushVersions","versions","getVersion","getVersionMap","getInfo","info","blockIconURI","blocks","convertToInfo","color1","blockColor","color2","menuColor","color3","menuSelectColor","collectMenus","isBlockGetter","displayText","argumentsInfo","fromEntries","uri","accumulation","convertToArgumentInfo","blockType","getButtonID","bind","func","names","types","handlers","zipArgs","registerDynamicMenu","getItems","blockBundleEvent","getAccessorPrefix","setAccessorPrefix","blockInfoOrGetter","internalFuncName","methodName","returns","scratchType","createBlockDefiner","objOrGetter","extension","argumentMethods","attachArgumentMethods","createBlockDecorator","params","indexKey","methods","method","tryUpdateKey","asBlockMetaData","getBlockMetaData","metadata","orderedNames","parseText","rest","extractMenuOptions","sort","convertAndInsertBlock","placeholder","template","getItemsPlaceholder","handlerPlaceholder","isDynamicMenu","menuName","acceptsReporters","validBlock","legacyBlock","validArg","pair","legacy","modern","getDynamicMenuName","legacySupportMixin","__isLegacy","orderArgumentNamesByBlock","getArgNames","validatedInfo","super","validateAndAttach","metaData","legacyID","legacyBlocks","legacyMenus","getLegacyInfo","mutableBlocks","self","updates","legacyArgs","modernArgs","argNames","replaceAt","implementation","util","remap","remapper","menuUpdates","legacyName","modernName","flat","isSvgText","nodeName","fills","success","warning","textAttributes","applyAttributes","attributes","setAttribute","createElements","createElementNS","equilateralTrianglePoints","reduction","shift","y","getEquilateralTrianglePoints","getCategoryElements","topLevel","title","innerHTML","Format","canvas","video","videoDimensions","videoDevice","ioDevices","getVideoFrame","getFrame","setVideoTransparency","transparency","setPreviewGhost","enableVideo","mirror","provider","disableVideo","optionalMixins","ExtensionWithCustomArgumentSupport","customSaveData","makeCustomArgument","component","initial","acceptReportersHandler","processMenuForCustomArgument","acceptsReports","initialID","Component","interop","setter","label","drawable","createDrawable","renderer","skin","createBitmapSkin","updateDrawableSkinId","setTransparency","updateDrawableEffect","setVisible","visible","updateDrawableVisible","updateBitmapSkin","destroy","destroyDrawable","destroySkin","addCostumes","addCostume","action","dimensions","setDimensions","hidden","getDataURL","clearRect","putImageData","restore","getUrlHelper","addCostumeBitmap","bitmapImage","Date","now","storage","dataFormat","DataFormat","PNG","assetType","AssetType","ImageBitmap","dataBuffer","asset","createAsset","assetId","costume","md5","getCostumes","setCostume","setCostumeByName","costumeIndex","getCostumeIndexByName","legacySupport","setTransparencyBlock","ExtensionWithSetVideoTransparencyBlock","_classSuper","setVideoTransparencyBlock","_instanceExtraInitializers","_setVideoTransparencyBlock_decorators","static","private","_metadata","toggleVideoBlock","ExtensionWithToggleVideoBlock","_toggleVideoBlock_decorators","appInventor","withinAppInventor","indicators","indicate","position","msg","alert","rect","triangle","points","el","getBBox","rx","removeChild","openAlert","indicateFor","seconds_1","seconds","ConstructableExtension","internal_init","extensionManager","getExtensionManager","extensionsMap","ExtensionBase","FORBIDDEN","CORE_EXTENSIONS","primitiveOpcodeInfoMap","math_number","math_positive_number","math_whole_number","math_integer","math_angle","colour_picker","event_broadcast_menu","data_variable","data_listcontents","soup_","uid","soupLength","charAt","supported","mixinName","includes","extensionBundleEvent","addOns","Base","alterOpcodes","objTargets","newTargets","object","blockId","blockInfoIndex","alterJSON","projectJSON","targetObjects","targets","targetPaneOrder","layerOrder","newBlocks","blockJSON","version","blockOpcode","regex","matches","match","versionMatch","extensionID","getExtensionIdForOpcode","blocksInfo","acc","tempBlock","oldIndex","nameMap","createNameMap","originalType","first","blockArgs","removeImageEntries","inputs","variables","gatherInputs","fields","gatherFields","totalList","concat","newInputs","newFields","transform","mechanism","values","newEntries","mappings","updateEntries","updateDictionary","previousType","argIndex","fieldValue","typeNum","getType","parent","oldId","parentBlock","oldID","newBlock","create","MESSAGE","shadow","inputBlock","prefix","tempName","previousName","dict","filteredDict","input","keyIndex","argList","field","argType","originalDict","keyMapping","updatedDict","oldKey","newKey","newEntry","removeInput","removeBlock","argInfo","defaultVal","Result","allSupported","recursivelyApplyMixinsAndDependencies","addons","alreadyAdded","addon","MixedIn","createMixin","mixins","dependency","tryCaptureDependencies","Extension","_super","defineBlocks","validateOpcode","process","strings","placeholders","str","makeDecorator","builderOrStrings","instance","scratch","reporter","command","hat","button","AuxiliaryExtensionInfo","Branch","Exit","Enter","First","Second","Third","Fourth","Fifth","Sixth","Seventh","FrameworkID","RuntimeEvent","ScriptGlowOn","ScriptGlowOff","BlockGlowOn","BlockGlowOff","HasCloudDataUpdate","TurboModeOn","TurboModeOff","RecordingOn","RecordingOff","ProjectStart","ProjectRunStart","ProjectRunStop","ProjectStopAll","StopForTarget","VisualReport","ProjectLoaded","ProjectChanged","ToolboxExtensionsNeedUpdate","TargetsUpdate","MonitorsUpdate","BlockDragUpdate","BlockDragEnd","ExtensionAdded","ExtensionFieldAdded","PeripheralListUpdate","PeripheralConnected","PeripheralDisconnected","PeripheralRequestError","PeripheralConnectionLostError","PeripheralScanTimeout","MicListening","BlocksInfoUpdate","RuntimeStarted","RuntimeDisposed","BlocksNeedUpdate","TargetWasCreated","Say","SaveDataHandler","ScratchBlocksConstants","OutputShapeHexagonal","OutputShapeRound","OutputShapeSquare","TargetType","Sprite","Stage","VariableType","Scalar","List","BrooadcastMessage","activeClass","buttonBlock","copyTo","source","decode","matchAll","replacements","code","fromCharCode","modified","encode","invalidCharacters","char","fetchWithTimeout","resource","timeoutMs","controller","AbortController","abort","response","fetch","signal","getTextFromMenuItem","getValueFromMenuItem","getterBlock","isValidID","test","flags","blockMethodBroker","definer","decorator","legacyDefinition","definitions","throwTypeOnlyError","legacyExtension","LegacySupport","legacyInfo","ExtensionWithLegacySupport","legacySupportWithInfoArgument","originalClassName","ReservedNames","Menus","Blocks","ArgumentNamesByBlock","loadExternalScript","onError","px","numberOf","reactiveInvoke","extensionAssignment","funcName","reactiveSet","propertyName","rgbToHex","rgb","substr","decimalToHex","rgbToDecimal","setterBlock","blockInfo","splitOnCapitals","tryCastToArgumentType","onFailure","untilCondition","condition_1","condition","untilExternalGlobalVariableLoaded","globalVariableName","untilReady","obj_1","ready","validGenericExtension","failure","config","wrapClamp","n","min","max","range"],"mappings":"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","x_google_ignoreList":[1]}