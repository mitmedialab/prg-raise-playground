<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Line Detection</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #outputImage { max-width: 100%; height: auto; border: 1px solid #ddd; }
        #controls { margin: 20px 0; }
        #ipInput { padding: 5px; width: 200px; }
        button { padding: 5px 10px; cursor: pointer; }
    </style>
    <script>
        const port = { camera: 8000 };
        const endpoint = { video: 'video_feed' };

        class LineDetector {
            constructor(raspberryPiIp, width = 640, height = 480) {
                this.raspberryPiIp = raspberryPiIp;
                this.width = width;
                this.height = height;
                this.canvas = document.createElement('canvas');
                this.canvas.width = width;
                this.canvas.height = height;
                this.ctx = this.canvas.getContext('2d');
                this.lastDetectedLine = [];
                this.isProcessing = false;
            }

            async detectLine() {
                if (this.isProcessing) return this.canvas.toDataURL();
                this.isProcessing = true;

                try {
                    const image = await this.loadImage(`http://${this.raspberryPiIp}:${port.camera}/${endpoint.video}`);
                    this.ctx.drawImage(image, 0, 0, this.width, this.height);
                    const imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                    
                    // Convert to grayscale with extreme contrast to isolate dark line
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                        // Extreme contrast to isolate dark line
                        const contrast = 5.0;
                        const brightnessFactor = -50;
                        const enhancedGray = Math.min(255, Math.max(0, (gray - 128) * contrast + 128 + brightnessFactor));
                        // Very aggressive threshold - only keep the darkest pixels
                        const threshold = 60;
                        const binaryValue = enhancedGray < threshold ? 0 : 255;
                        data[i] = binaryValue;
                        data[i + 1] = binaryValue;
                        data[i + 2] = binaryValue;
                        data[i + 3] = 255;
                    }

                    // Find the single longest continuous dark line
                    const contours = this.findContours(imageData);
                    let longestLine = null;
                    let maxLength = 0;

                    for (const contour of contours) {
                        if (contour.length > maxLength) {
                            // Verify it's a line-like shape
                            const xs = contour.map(p => p[0]);
                            const ys = contour.map(p => p[1]);
                            const width = Math.max(...xs) - Math.min(...xs);
                            const height = Math.max(...ys) - Math.min(...ys);
                            const ratio = Math.max(width, height) / Math.min(width, height);
                            
                            // Must be elongated and continuous
                            if (ratio > 3 && contour.length > 50) {
                                maxLength = contour.length;
                                longestLine = contour;
                            }
                        }
                    }

                    // Clear and draw original image faintly
                    this.ctx.clearRect(0, 0, this.width, this.height);
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.drawImage(image, 0, 0, this.width, this.height);
                    this.ctx.globalAlpha = 1.0;

                    // Draw detected line in blue
                    if (longestLine) {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = '#0000FF';
                        this.ctx.lineWidth = 3;
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';

                        longestLine.forEach(([x, y], i) => {
                            if (i === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        });
                        this.ctx.stroke();
                        this.lastDetectedLine = longestLine;
                    }

                    return this.canvas.toDataURL();
                } catch (error) {
                    console.error('Error detecting line:', error);
                    return null;
                } finally {
                    this.isProcessing = false;
                }
            }

            loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = src;
                });
            }

            findContours(imageData) {
                const contours = [];
                const data = imageData.data;
                const visited = new Set();
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const idx = (y * this.width + x) * 4;
                        const key = `${x},${y}`;
                        
                        if (data[idx] === 0 && !visited.has(key)) {
                            const contour = [];
                            this.traceContour(x, y, data, visited, contour);
                            if (contour.length > 0) {
                                contours.push(contour);
                            }
                        }
                    }
                }
                return contours;
            }

            traceContour(startX, startY, data, visited, contour) {
                const stack = [[startX, startY]];
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const key = `${x},${y}`;
                    
                    if (visited.has(key)) continue;
                    
                    visited.add(key);
                    contour.push([x, y]);
                    
                    // Check 8-connected neighbors
                    const neighbors = [
                        [1, 0], [1, 1], [0, 1], [-1, 1],
                        [-1, 0], [-1, -1], [0, -1], [1, -1]
                    ];
                    
                    for (const [dx, dy] of neighbors) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                            const idx = (ny * this.width + nx) * 4;
                            if (data[idx] === 0 && !visited.has(`${nx},${ny}`)) {
                                stack.push([nx, ny]);
                            }
                        }
                    }
                }
            }
        }

        let detector;
        let updateInterval;

        function initializeDetector() {
            const raspberryPiIp = document.getElementById('ipInput').value;
            if (!raspberryPiIp) {
                alert('Please enter a valid IP address');
                return;
            }
            detector = new LineDetector(raspberryPiIp);
            clearInterval(updateInterval);
            updateImage();
            updateInterval = setInterval(updateImage, 500);
        }

        async function updateImage() {
            if (detector) {
                const imageDataUrl = await detector.detectLine();
                if (imageDataUrl) {
                    document.getElementById('outputImage').src = imageDataUrl;
                }
            }
        }
    </script>
</head>
<body>
    <h1>Black Line Detection</h1>
    <div id="controls">
        <input type="text" id="ipInput" placeholder="IP Address">
        <button onclick="initializeDetector()">Start Detection</button>
    </div>
    <img id="outputImage" alt="Processed Image">
</body>
</html>