<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Line Detection</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #outputImage { max-width: 100%; height: auto; border: 1px solid #ddd; }
        #controls { margin: 20px 0; }
        #ipInput { padding: 5px; width: 200px; }
        button { padding: 5px 10px; cursor: pointer; }
    </style>
    <script>
        const port = { camera: 8000 };
        const endpoint = { video: 'video_feed' };

        class LineDetector {
            constructor(raspberryPiIp, width = 640, height = 480) {
                this.raspberryPiIp = raspberryPiIp;
                this.width = width;
                this.height = height;
                this.canvas = document.createElement('canvas');
                this.canvas.width = width;
                this.canvas.height = height;
                this.ctx = this.canvas.getContext('2d');
                this.lastDetectedLine = [];
                this.frameCount = 0;
                this.allCoordinates = [];
            }

            async detectLine() {
                try {
                    const image = await this.loadImage(`http://${this.raspberryPiIp}:${port.camera}/${endpoint.video}`);
                    this.ctx.drawImage(image, 0, 0, this.width, this.height);
                    const imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                    const preprocessedImageData = this.preprocessImage(imageData);
                    const lineCoordinates = this.processImageData(preprocessedImageData);
                    const filteredCoordinates = this.filterContinuousLine(lineCoordinates);
                    console.log("coordinates");
                    console.log(filteredCoordinates);
                    if (filteredCoordinates.length > 0) {
                        this.lastDetectedLine = filteredCoordinates;
                    }

                    if (this.frameCount < 7) {
                        this.allCoordinates.push(filteredCoordinates);
                        this.frameCount++;
                        if (this.frameCount === 7) {
                            this.writeCoordinatesToFile(this.allCoordinates);
                        }
                    }

                    this.drawLine(this.lastDetectedLine);
                    return this.canvas.toDataURL();
                } catch (error) {
                    console.error('Error detecting line:', error);
                    return null;
                }
            }

            loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = src;
                });
            }

            preprocessImage(imageData) {
                const data = imageData.data;
                const threshold = this.calculateBlackThreshold(data);
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    const brightness = (r + g + b) / 3;
                    
                    if (brightness < threshold) {
                        data[i] = 0;     // Set red to min
                        data[i + 1] = 0; // Set green to min
                        data[i + 2] = 0; // Set blue to min
                    } else {
                        data[i] = 255;     // Set red to max
                        data[i + 1] = 255; // Set green to max
                        data[i + 2] = 255; // Set blue to max
                    }
                }
                
                return imageData;
            }

            calculateBlackThreshold(data) {
                let brightnessValues = [];
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    brightnessValues.push(brightness);
                }
                brightnessValues.sort((a, b) => a - b);
                return brightnessValues[Math.floor(brightnessValues.length * 0.3)]; // 30th percentile as threshold
            }

            processImageData(imageData) {
                const lineCoordinates = [];

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const index = (y * this.width + x) * 4;
                        const r = imageData.data[index];
                        
                        if (r === 0) {  // Check for black pixels (preprocessed black line)
                            lineCoordinates.push([x, y]);
                        }   
                    }
                }
                return lineCoordinates.sort((a, b) => a[1] - b[1]);
            }

            filterContinuousLine(coordinates) {
                if (coordinates.length < 2) return coordinates;

                const filteredCoordinates = [coordinates[0]];
                const maxDistance = 20; // Maximum allowed distance between consecutive points

                for (let i = 1; i < coordinates.length; i++) {
                    const [prevX, prevY] = filteredCoordinates[filteredCoordinates.length - 1];
                    const [currentX, currentY] = coordinates[i];
                    
                    const distance = Math.sqrt(Math.pow(currentX - prevX, 2) + Math.pow(currentY - prevY, 2));
                    
                    if (distance <= maxDistance) {
                        filteredCoordinates.push(coordinates[i]);
                    }
                }

                return filteredCoordinates;
            }

            drawLine(coordinates) {
                this.ctx.beginPath();
                this.ctx.strokeStyle = 'red';
                this.ctx.lineWidth = 2;
                coordinates.forEach(([x, y], i) => {
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();
            }

            writeCoordinatesToFile(allCoordinates) {
                const content = allCoordinates.map((frame, index) => 
                    `Frame ${index + 1}:\n${frame.map(coord => coord.join(',')).join('\n')}\n`
                ).join('\n');
                const blob = new Blob([content], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'coordinates.txt';
                a.click();
                URL.revokeObjectURL(a.href);
            }
        }

        let detector;
        let updateInterval;

        function initializeDetector() {
            const raspberryPiIp = document.getElementById('ipInput').value;
            if (!raspberryPiIp) {
                alert('Please enter a valid IP address');
                return;
            }
            detector = new LineDetector(raspberryPiIp);
            clearInterval(updateInterval);
            updateImage();
            updateInterval = setInterval(updateImage, 500);
        }

        async function updateImage() {
            if (detector) {
                const imageDataUrl = await detector.detectLine();
                if (imageDataUrl) {
                    document.getElementById('outputImage').src = imageDataUrl;
                }
            }
        }
    </script>
</head>
<body>
    <h1>Black Line Detection</h1>
    <div id="controls">
        <input type="text" id="ipInput" placeholder="IP Address">
        <button onclick="initializeDetector()">Start Detection</button>
    </div>
    <img id="outputImage" alt="Processed Image">
</body>
</html>
