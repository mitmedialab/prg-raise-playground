<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Line Detection</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #outputImage { max-width: 100%; height: auto; border: 1px solid #ddd; }
        #controls { margin: 20px 0; }
        #ipInput { padding: 5px; width: 200px; }
        button { padding: 5px 10px; cursor: pointer; }
    </style>
    <script>
        const port = { camera: 8000 };
        const endpoint = { video: 'video_feed' };

        class LineDetector {
            constructor(raspberryPiIp, width = 640, height = 480) {
                this.raspberryPiIp = raspberryPiIp;
                this.width = width;
                this.height = height;
                this.canvas = document.createElement('canvas');
                this.canvas.width = width;
                this.canvas.height = height;
                this.ctx = this.canvas.getContext('2d');
                this.lastDetectedLine = [];
                this.isProcessing = false;
            }

            async detectLine() {
                if (this.isProcessing) return this.canvas.toDataURL();
                this.isProcessing = true;

                try {
                    const image = await this.loadImage(`http://${this.raspberryPiIp}:${port.camera}/${endpoint.video}`);
                    this.ctx.drawImage(image, 0, 0, this.width, this.height);
                    const imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                    
                    // Convert to grayscale
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = gray;
                        data[i + 1] = gray;
                        data[i + 2] = gray;
                    }
                    this.ctx.putImageData(imageData, 0, 0);

                    // Apply Gaussian blur
                    const blurredData = this.gaussianBlur(imageData);
                    this.ctx.putImageData(blurredData, 0, 0);

                    // Apply threshold
                    const thresholdedData = this.threshold(blurredData);
                    this.ctx.putImageData(thresholdedData, 0, 0);

                    // Find contours and get largest
                    const contours = this.findContours(thresholdedData);
                    const sortedContours = contours.sort((c1, c2) => c2.length - c1.length);

                    if (sortedContours.length > 0) {
                        this.lastDetectedLine = sortedContours[0];
                        this.drawLine(this.lastDetectedLine);
                    }

                    return this.canvas.toDataURL();
                } catch (error) {
                    console.error('Error detecting line:', error);
                    return null;
                } finally {
                    this.isProcessing = false;
                }
            }

            loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = src;
                });
            }

            gaussianBlur(imageData) {
                const data = imageData.data;
                const result = new ImageData(new Uint8ClampedArray(data), this.width, this.height);
                const kernel = [
                    [1, 4, 6, 4, 1],
                    [4, 16, 24, 16, 4],
                    [6, 24, 36, 24, 6],
                    [4, 16, 24, 16, 4],
                    [1, 4, 6, 4, 1]
                ];
                const kernelSize = 5;
                const kernelSum = 256;

                for (let y = 2; y < this.height - 2; y++) {
                    for (let x = 2; x < this.width - 2; x++) {
                        let sum = 0;
                        for (let ky = 0; ky < kernelSize; ky++) {
                            for (let kx = 0; kx < kernelSize; kx++) {
                                const px = x + kx - 2;
                                const py = y + ky - 2;
                                const i = (py * this.width + px) * 4;
                                sum += data[i] * kernel[ky][kx];
                            }
                        }
                        const i = (y * this.width + x) * 4;
                        const val = sum / kernelSum;
                        result.data[i] = val;
                        result.data[i + 1] = val;
                        result.data[i + 2] = val;
                        result.data[i + 3] = 255;
                    }
                }
                return result;
            }

            threshold(imageData) {
                const data = imageData.data;
                const result = new ImageData(new Uint8ClampedArray(data), this.width, this.height);
                
                for (let i = 0; i < data.length; i += 4) {
                    const val = data[i] < 128 ? 0 : 255;
                    result.data[i] = val;
                    result.data[i + 1] = val;
                    result.data[i + 2] = val;
                    result.data[i + 3] = 255;
                }
                return result;
            }

            findContours(imageData) {
                const contours = [];
                const data = imageData.data;
                const visited = new Set();
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const idx = (y * this.width + x) * 4;
                        const key = `${x},${y}`;
                        
                        if (data[idx] === 0 && !visited.has(key)) {
                            const contour = [];
                            this.traceContour(x, y, data, visited, contour);
                            if (contour.length > 0) {
                                contours.push(contour);
                            }
                        }
                    }
                }
                return contours;
            }

            traceContour(startX, startY, data, visited, contour) {
                const stack = [[startX, startY]];
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const key = `${x},${y}`;
                    
                    if (visited.has(key)) continue;
                    
                    visited.add(key);
                    contour.push([x, y]);
                    
                    // Check 8-connected neighbors
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                                const idx = (ny * this.width + nx) * 4;
                                if (data[idx] === 0 && !visited.has(`${nx},${ny}`)) {
                                    stack.push([nx, ny]);
                                }
                            }
                        }
                    }
                }
            }

            drawLine(coordinates) {
                this.ctx.beginPath();
                this.ctx.strokeStyle = 'red';
                this.ctx.lineWidth = 2;
                coordinates.forEach(([x, y], i) => {
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();
            }
        }

        let detector;
        let updateInterval;

        function initializeDetector() {
            const raspberryPiIp = document.getElementById('ipInput').value;
            if (!raspberryPiIp) {
                alert('Please enter a valid IP address');
                return;
            }
            detector = new LineDetector(raspberryPiIp);
            clearInterval(updateInterval);
            updateImage();
            updateInterval = setInterval(updateImage, 500);
        }

        async function updateImage() {
            if (detector) {
                const imageDataUrl = await detector.detectLine();
                if (imageDataUrl) {
                    document.getElementById('outputImage').src = imageDataUrl;
                }
            }
        }
    </script>
</head>
<body>
    <h1>Black Line Detection</h1>
    <div id="controls">
        <input type="text" id="ipInput" placeholder="IP Address">
        <button onclick="initializeDetector()">Start Detection</button>
    </div>
    <img id="outputImage" alt="Processed Image">
</body>
</html>
